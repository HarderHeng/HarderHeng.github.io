<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPP中vector的用法</title>
    <url>/2024/02/10/Cpp%E4%B8%ADvector%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、vector理解"><a href="#一、vector理解" class="headerlink" title="一、vector理解"></a>一、vector理解</h3><p>vector是用来声明动态数组的，头文件为 &lt; vector &gt;。</p>
<p>vector是线性的，和数组一样可以通过下标进行快速访问</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;Num;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;Num(<span class="number">2</span>); <span class="comment">//只有一个参数时，代表声明的数组长度</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;Num(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//有两个参数时，代表声明的数组长度以及初始化</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码创建了一个<em>int</em>类型的可变数组<em>Num</em>，这个数组可以像普通数组一样访问和修改数值。</p>
<p>vector和数组名之间可以加一个空格。数组名后面可以跟括号，括号中可以跟参数。</p>
<h3 id="二、vector常用函数"><a href="#二、vector常用函数" class="headerlink" title="二、vector常用函数"></a>二、vector常用函数</h3><p>创建vector后，默认vector中没有元素。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;Num;</span><br><span class="line">Num.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//在数组的末尾添加一个元素1</span></span><br><span class="line">Num.<span class="built_in">pop_back</span>(); <span class="comment">//在数组的末尾删除一个元素</span></span><br><span class="line">Num.<span class="built_in">erase</span>(iterator it); <span class="comment">//删除迭代器指向的元素，删除后容器会自动调整</span></span><br><span class="line">cout&lt;&lt;Num.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">//数组的大小</span></span><br><span class="line">Num.<span class="built_in">clear</span>(); <span class="comment">//清除所有的元素</span></span><br></pre></td></tr></table></figure></div>

<p>vector除了通过数组下标进行遍历之外，还可以通过迭代器进行遍历。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//声明一个迭代器</span></span><br><span class="line"><span class="keyword">for</span>(it = Num.<span class="built_in">begin</span>(); it &lt; Num.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//begin()用来访问数组的起始位置，end()用来访问数组的最后一个元素的后一个位置</span></span><br><span class="line"><span class="comment">//it作为一个数组指针</span></span><br></pre></td></tr></table></figure></div>

<h3 id="三、二维数组"><a href="#三、二维数组" class="headerlink" title="三、二维数组"></a>三、二维数组</h3><p>创建二维数组时和常规数组类似，总是从低维度操作，高维度存储着低维度的起始位置。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">&#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>vector</tag>
        <tag>动态数组</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>EmbeddedSystem</title>
    <url>/2024/02/27/EmbeddedSystem/</url>
    <content><![CDATA[<h3 id="一、用Keil重构uc-OS系统"><a href="#一、用Keil重构uc-OS系统" class="headerlink" title="一、用Keil重构uc&#x2F;OS系统"></a>一、用Keil重构uc&#x2F;OS系统</h3><h4 id="1、uC-OS结构"><a href="#1、uC-OS结构" class="headerlink" title="1、uC&#x2F;OS结构"></a>1、uC&#x2F;OS结构</h4><ul>
<li>处理器相关</li>
</ul>
<p>os_cfg.h</p>
<p>os_cpu_a.asm</p>
<p>os_cpu_c.c(<strong>cortex M4</strong>)</p>
<ul>
<li>处理器无关</li>
<li>Configuration</li>
</ul>
<h4 id="2、Compile-Link"><a href="#2、Compile-Link" class="headerlink" title="2、Compile &amp; Link"></a>2、Compile &amp; Link</h4><p>单片机在编译阶段确定代码运行的地址，</p>
<p>.c-&gt;预处理-&gt; .i-&gt;编译-&gt;.s-&gt;汇编-&gt;.o(<strong>可重定位目标文件</strong>)-&gt;链接-&gt;.exe</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>操作系统</tag>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2024/02/27/DataBase/</url>
    <content><![CDATA[<h3 id="一、数据库理解"><a href="#一、数据库理解" class="headerlink" title="一、数据库理解"></a>一、数据库理解</h3><h4 id="1、什么是数据库"><a href="#1、什么是数据库" class="headerlink" title="1、什么是数据库"></a>1、什么是数据库</h4><p>数据库是一种依照特定数据模型，组织、存储和管理数据的文件集合。组织与存储系统数据，为系统软件从中存取从中存取数据提供支持。</p>
<p><strong>关系型数据库：</strong>在关系模型基础上，由多张相互连接的二维表组成的数据库。</p>
<h4 id="2、什么是数据模型"><a href="#2、什么是数据模型" class="headerlink" title="2、什么是数据模型"></a>2、什么是数据模型</h4><p>数据模型是用于描述和组织数据的概念和结构的一种方式。它定义了数据的组织方式、数据之间的关系以及对数据进行操作的规则和约束。数据模型提供了一种抽象层，更好的理解和管理数据。</p>
<ul>
<li><strong>数据结构</strong> <em>数据组织的方式</em></li>
<li><strong>数据操作</strong> <em>对数据结构进行的操作</em></li>
<li><strong>数据约束</strong> <em>用于描述数据之间的语意联系</em></li>
</ul>
<p>关系模型中数据的逻辑结构是一张二维表。</p>
<p>* </p>
<h4 id="3、什么是SQL"><a href="#3、什么是SQL" class="headerlink" title="3、什么是SQL"></a>3、什么是SQL</h4><p>SQL是用来操作关系型数据库的语言，学会了SQL语言就可以操作所有的数据库。</p>
<h4 id="4、什么是数据库系统"><a href="#4、什么是数据库系统" class="headerlink" title="4、什么是数据库系统"></a>4、什么是数据库系统</h4><p>数据库系统由<strong>数据库、数据库管理系统、数据库管理员、数据库应用程序、最终用户</strong>组成。<strong>管理员</strong>通过<strong>数据库管理系统</strong>来管理数据库，<strong>数据库应用程序</strong>通过<strong>数据库管理系统</strong>提供的API进行数据的调用和操作，<strong>最终用户</strong>可以使用数据库应用程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/Database1.png"
                      alt="Database1"
                ></p>
<h3 id="二、MySql安装"><a href="#二、MySql安装" class="headerlink" title="二、MySql安装"></a>二、MySql安装</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>（这里准摆在windows中安装）</p>
<p>在MySql官网下载community版本的MySql。</p>
<h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><ul>
<li>直接执行安装程序。</li>
<li>选择完整安装，完整安装后会出现配置程序。</li>
<li>在配置程序中基本可以默认，后面需要自己配置一个root密码，记住这个root密码。</li>
<li>在刚才的安装过程中有一个安装位置，找到安装位置中的bin文件夹，复制整个路径然后为这个路径创建环境变量。</li>
<li>可以尝试在终端中输入<code>mysql -u root -p</code>然后输入root的密码，就能看到MySql成功安装了。</li>
</ul>
<p>安装后MySql服务会自动启动， 并且会开机自启，服务的名称是<code>MySQL**</code>，后面是安装MySql时的端口号（以下使用我的端口号83）。</p>
<p>在管理员终端中可以启动和停止该服务，使用<code>net start MySql83</code>和<code>net stop MySql83</code>命令启动和停止数据库服务。</p>
<h4 id="3、连接到MySql"><a href="#3、连接到MySql" class="headerlink" title="3、连接到MySql"></a>3、连接到MySql</h4><p><em><strong>直接安装MySql Workbench可以进行可视化的连接。</strong></em></p>
<ul>
<li>使用MySQL命令行控制台进行连接，启动命令行控制台，然后输入root密码。</li>
<li>在配置环境变量后也可以使用普通终端<code>mysql -u root -p</code>进行连接。</li>
</ul>
<h3 id="三、SQL语言"><a href="#三、SQL语言" class="headerlink" title="三、SQL语言"></a>三、SQL语言</h3><ul>
<li><strong>DDL：</strong>Data Definition Language，数据定义语言，用来定义数据库对象，数据库、表、字段等。</li>
<li><strong>DML：</strong>Data Manipulation Language，数据操作语言，用来对数据库对象进行增删改查的操作。</li>
<li><strong>DQL：</strong>Data Query Language，数据查询语言，用来查询数据库中表的记录。</li>
<li><strong>DCL：</strong>Data Control Language，数据控制语言，用来创建数据库用户，控制数据库的访问权限。</li>
<li><strong>TPL：</strong>Transaction Process Language， 事务处理语言，内部数据处理。</li>
<li><strong>CCL：</strong>Cursor Control Language，用于数据库游标操作的语句。</li>
</ul>
<h4 id="1、DDL"><a href="#1、DDL" class="headerlink" title="1、DDL"></a>1、DDL</h4><ul>
<li><p>查询所有数据库 <code>show databases</code></p>
</li>
<li><p>查询当前所处的数据库 <code>select database()</code></p>
</li>
<li><p>创建新数据库 <code>create database [if not exists] &#123;Name&#125; [default charset &#123;字符集&#125;] [collate 排列规则] </code></p>
</li>
</ul>
<p><em>创建新数据库可以有很多可选项：如果不存在则创建； 默认字符集；排列规则</em></p>
<ul>
<li><p>删除数据库 <code>drop database [if exists] &#123;Name&#125;</code></p>
</li>
<li><p>切换数据库 <code>use &#123;Name&#125;</code></p>
</li>
</ul>
<p>+++</p>
<p><strong><a href="/2024/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3">约束和数据结构详解</a></strong></p>
<ul>
<li>查询当前数据库所有表 <code>show tables</code></li>
<li>创建新表 <code>create table &#123;Name&#125; ( &#123;字段名&#125; &#123;字段类型&#125; [约束或参数] );</code></li>
<li>删除表 <code>drop table &#123;Name&#125;</code></li>
</ul>
<h4 id="2、DML"><a href="#2、DML" class="headerlink" title="2、DML"></a>2、DML</h4><ul>
<li>从数据库表中获取数据<code>select &#123;ColumnName&#125; from &#123;TableName&#125;</code> <em>如果要选择所有字段直接使用<code>*</code>作为字段名</em></li>
<li>更新数据库表中的数据<code>update &#123;TableName&#125; set &#123;ColumnName&#125; = &#123;Value&#125;,···</code>也就是将表中的指定字段变成指定值</li>
<li>从数据库表中删除数据<code>dlete &#123;TableName&#125;</code> </li>
<li>从数据库表中插入数据<code>insert into &#123;TableName&#125; (column,column,···) values (value, value),(value,value),···</code></li>
</ul>
<p><em>在获取数据、更新数据和删除数据时，默认会对所有的数据条目进行操作，如果要指定一部分数据条目，请使用 where 语句</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习过程</title>
    <url>/2024/01/20/Java%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="java学习"><a href="#java学习" class="headerlink" title="java学习"></a>java学习</h1><h3 id="一、java简介"><a href="#一、java简介" class="headerlink" title="一、java简介"></a>一、java简介</h3><p>java是一门面向对象的编程语言。</p>
<p>java SE、EE和ME分别对应标准版，企业版，微型版</p>
<p>先执行javac对源文件进行编译，编译成class字节码文件，然后使用java命令对字节码文件的类进行解释，解释的过程放在java虚拟机上，所以可以跨平台运行。</p>
<h3 id="二、java基本语法"><a href="#二、java基本语法" class="headerlink" title="二、java基本语法"></a>二、java基本语法</h3><p>一整个java程序是一系列互相调用的对象的集合。</p>
<p><strong>类</strong>：类是一个模版，具有一系列的状态和行为。</p>
<p><strong>对象</strong>：对象是类的一个实例，具有确定的特征和确定的行为</p>
<p><strong>方法</strong>：方法就是对象的行为，一个类可以用很多方法。</p>
<p><strong>实例变量</strong>：实例变量就是对象的状态。</p>
<p>一个源文件只能有一个<code>public</code>类，可以有多个非<code>public</code>类。</p>
<p>import要放在package之前，package要放在整个程序之前，可以包含类和接口。</p>
<p>所有的java程序都会执行类的方法<code>main</code>。</p>
<p>类名首字母及往后每个单词的首字母大写 ，方法名第一个单词首字母小写，往后每个单词首字母大写。</p>
<p>java的注释和c以及c艹一样 ，可以单行也可以多行注释。</p>
<p>通过已有的类定义新的类叫做继承，新定义的类叫做子类，被继承的类叫做超类。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><em><strong>成员变量</strong></em>（也叫做实例变量）被定义在类中，方法体之外，类成员可以拥有被实例化的成员变量，成员变量可以被方法访问，在对象被创建时创建，在对象被销毁时销毁。</p>
<p><em><strong>局部变量</strong></em>被定义在类的方法中，在方法中被初始化，方法结束后就自动销毁，局部变量使用之前必须初始化，和c的局部变量一样。</p>
<p><em><strong>静态变量</strong></em>（static）定义在类中，方法体之外的，静态变量的值在程序运行期间只有一个副本，这个变量是该类的属性，不管是哪个实例对象都具有这个静态变量的值。在加载类（定义类时）需要给定义，不定义会报错。还有一种<strong>常量</strong>需要用<strong>final</strong>关键字定义，常量的值不能改变，静态变量的值可以改变。静态变量可以被修饰（常用public）</p>
<p>变量可以连续声明，定义变量后可以赋值。</p>
<p>变量强制转换顺序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </span><br></pre></td></tr></table></figure></div>



<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>每个类都应该有一个构造的方法，构造的方法必须与类的名字相同，创建类的对象时需要用到构造方法。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>有类和类的构造方法，就可以用<code>new</code>来创建对象。</p>
<p>创建对象的格式为<code>类名</code> <code>对象名</code> &#x3D; new <code>构造方法</code></p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p><em><strong>public</strong></em>对所有类可见。</p>
<p><em><strong>protected</strong></em>对同一个包内的类和子类可见。</p>
<p><em><strong>default</strong></em>同一包内可见。</p>
<p><em><strong>private</strong></em>同一类可见，类和接口不能用。</p>
<p><em><strong>static</strong></em>静态变量，也可以用来声明独立于对象的静态方法，静态方法不能使用类的非静态变量，静态方法和静态变量类似，可以独立于实例存在，但是要依赖于构造类来调用。</p>
<p><em><strong>final</strong></em>不能被更改的变量，常和<code>static</code>一起用创建类的常量。</p>
<h3 id="三、特殊类"><a href="#三、特殊类" class="headerlink" title="三、特殊类"></a>三、特殊类</h3><h4 id="NUMBER类"><a href="#NUMBER类" class="headerlink" title="NUMBER类"></a>NUMBER类</h4><p>将一个数字类型作为一个类使用。</p>
<h4 id="MATH类"><a href="#MATH类" class="headerlink" title="MATH类"></a>MATH类</h4><p>math类可以直接在主函数中调用，包含了一些常用的数学运算的方法，number类也可以使用。</p>
<h4 id="CHARACTER类"><a href="#CHARACTER类" class="headerlink" title="CHARACTER类"></a>CHARACTER类</h4><p>作为一个字符类，代替内置对象字符</p>
<h4 id="STRING类"><a href="#STRING类" class="headerlink" title="STRING类"></a>STRING类</h4><p>用STRING 类型new的类不能被更改，可以使用<strong>StringBuffer</strong>和<strong>StringBuilder</strong>类。</p>
<h3 id="四、细枝末节"><a href="#四、细枝末节" class="headerlink" title="四、细枝末节"></a>四、细枝末节</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>子类需要用到父类的一部分定义，就可以用继承</p>
<p><code>class SonName extends FatherName</code></p>
<p>父类也可以叫做基类和超类，子类也可以叫做派生类。</p>
<p>这样创建出来的子类具有父类中所有不被<code>protected</code>的变量和方法。</p>
<p><strong>1）成员变量重名</strong> 直接访问子类的变量时，如果是同名变量，则优先使用子类本身的，或者向上找到最近的父类的该变量。</p>
<p>间接通过方法访问变量时，方法定义在哪就优先使用该类的变量，如果没有就逐层向上找。</p>
<p><strong>2）成员方法重名</strong> 同名方法优先访问离自己最近的，如果自己没有这个方法就向上找。</p>
<p>在类中要访问自己的成员变量和方法时，可以使用关键词<em><strong>this</strong></em>，要访问父类的成员变量和方法时，可以使	用<em><strong>super</strong></em></p>
<p><strong>3）方法覆盖重写</strong> 用<code>@Override</code>可以表示覆盖重写，写一个和父类中方法同名的方法且参数列表相同的，就可以使用覆盖重写。子类方法的返回值范围必须小于等于父类方法的返回值范围。子类方法的权限必须大于等于父类方法的权限修饰符。方法覆盖重写只针对实例方法，对静态方法覆盖没有意义。</p>
<p><strong>4）方法重载</strong> 重写一个无参的方法将他变成有有参的方法，或者改变这个方法的参数列表。</p>
<p><strong>5）构造方法</strong> 子类中有一个默认的隐藏的<code>super()</code>调用父类的无参构造方法，构造子类对象时一定会先执行父类的<strong>无参构造方法</strong>。可以使用<strong>super（）</strong>关键字来调用父类构造方法，并将其重载。**super()**的父类构造调用必须是子类构造方法的第一句，即如果父类的构造方法有参，则必须使用带有一个参数的<code>super()</code>。</p>
<p><strong>6）this调用构造方法</strong>  在同一个类中可以有多个构造方法，多个构造方法可以有不同的参数（无参或者多个参数），在构造方法内可以通过 <code>this（...）</code> 直接调用另一个构造方法，调用本类的构造方法必须是第一句并且唯一，但是自带一个隐式的<code>super()</code>，不能够显式的重写调用 <code>super</code> 。构造方法多次调用时，来自父类的构造方法 <code>super()</code> 只会执行一次。</p>
<p><strong>7）抽象abstract</strong> 抽象方法必须在抽象类中，在定义类和方法之前加上abstract就是抽象类和抽象方法。必须要有一个子类来继承抽象父类，必须要有方法覆盖重写父类中的所有抽象方法<strong>（实现）</strong>。抽象父类不能直接创建对象。</p>
<p><em><strong>Final是终结符，不能产生子类。private 修饰的成员变量可以被继承，不能被子类访问</strong></em></p>
<h4 id="接口和包"><a href="#接口和包" class="headerlink" title="接口和包"></a>接口和包</h4><p><strong>包</strong>：也叫类库，也就是一组类的集合。必须作为源文件的第一句来声明包的名字。源文件必须放在包同名目录下，然后使用<code>javac -d .</code>就可以在当前目录下生成对应包名字的目录，并且把生成的<code>.class</code>文件直接放在同名目录下。</p>
<p>不同包中相同的类不会发生冲突，相同功能的类一般放在同一个包里，同一个包中的类可以相互访问，不同包里的类一般不能相互访问。</p>
<p><code>package</code>语句后可以跟<code>import</code>语句来导入其他包中的类，包中的类需要有<code>public</code>属性才可以被调用。</p>
<p><strong>接口</strong>： 接口是一种具有常量成员变量和抽象方法的抽象类，接口是一种引用数据类型。用关键词<strong>interface</strong>定义接口。</p>
<p>被定义的接口不能直接创建实例对象，必须用非抽象类通过非抽象的<strong>implement</strong>实现，implement是对接口的实现不是继承（和继承类似），非抽象类实现接口必须实现接口中的所有抽象方法。接口可以被继承，继承的特性和类继承类似。接口的继承可以多继承，即继承两个父接口。<em><strong>接口中的常量可以直接通过接口名称访问。</strong></em></p>
<p>定义接口的抽象方法时，要使用<code>public abstract</code>（可以选择性省略）。</p>
<p>接口中的默认方法，使用<code>default</code>创建默认方法，默认方法不需要实现类覆盖重写，可以直接被调用，也可以被覆盖重写。</p>
<p>接口中的静态方法，使用<code>static</code>创建方法，</p>
]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简单学习和实操</title>
    <url>/2024/01/20/Git%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h3 id="一、Git安装"><a href="#一、Git安装" class="headerlink" title="一、Git安装"></a>一、Git安装</h3><h3 id="二、Git基本操作"><a href="#二、Git基本操作" class="headerlink" title="二、Git基本操作"></a>二、Git基本操作</h3><p><strong>1）</strong>安装好Git后就可以对Git进行配置，使用命令<code>Git config</code>命令进行配置。初始配置一般会加上<code>--global</code>，即全局设置，在此台电脑上的所有工作区都适用的配置。刚开始需要配置邮箱账号和密码，为配置命令加上<code>user.name&quot; &quot;</code>和<code>user.email&quot; &quot;</code>的参数，就可以指定用户和邮箱。</p>
<p><strong>2）</strong>要想在一个本地工作区（也就是文件）中使用Git需要在对应的文件夹路径下使用<code>Git init</code>命令，之后就会在这个路径下自动生成一个默认隐藏的**.git**文件夹。</p>
<p>使用命令<code>git status</code>可以看到整个文件夹中所有文件（夹）的状态，即修改后有没有被添加进暂存区</p>
<p>Gitignore</p>
<p>创建.gitignore文件在其中添加以下内容</p>
<h4 id="Git工作模式理解"><a href="#Git工作模式理解" class="headerlink" title="Git工作模式理解"></a>Git工作模式理解</h4><p>Git在本地有两个仓库，分别是本地的本地仓库和本地的远程仓库。</p>
<ul>
<li>使用<code>git fetch</code>可以确保本地的远程仓库和实际的远程仓库保持一致，一般的<strong>查看远程仓库</strong>的信息也是查看的这个<strong>本地远程仓库</strong></li>
<li>使用<code>git pull</code>将本地仓库和远程仓库都更新成实际的远程仓库。</li>
</ul>
<p>使用git时除了仓库的概念还有分支的概念，一个仓库的一个分支是一个项目的单位。</p>
<p>本地会有一些分支，远程仓库也会有一些分支，当我们把远程仓库和本地仓库的分支进行链接后，就可以将本地的仓库push到远程仓库。</p>
<h4 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h4><ul>
<li><strong>查看分支</strong></li>
</ul>
<p><code>git branch</code>查看本地分支</p>
<p><code>git branch -r</code>查看远程分支，<em>这里查看的远程分支其实是本地的远程仓库</em></p>
<p><code>git branch -a</code>产看所有本地的和远程的分支</p>
<p><code>git branch --merged</code>查看已经合并到当前分支的所有分支</p>
<ul>
<li><strong>创建和切换分支</strong></li>
</ul>
<p><code>git branch &lt;新分支名称&gt;</code>创建新的分支</p>
<p><code>git checkout &lt;分支名称&gt;</code>切换分支</p>
<h4 id="Git多人工作模式之FeatureBranching"><a href="#Git多人工作模式之FeatureBranching" class="headerlink" title="Git多人工作模式之FeatureBranching"></a>Git多人工作模式之FeatureBranching</h4><h5 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h5><p>每次进行<strong>新的Feature</strong>开发时需要从<strong>Branch拉取一条Feature分支</strong>出来，并且在完成Feature分支的开发后将Feature<strong>合并</strong>回主分支，在合并后进行<strong>清除</strong>掉Feature分支以保证仓库的整洁。</p>
<ul>
<li><strong>创建分支</strong> 可以选择在直接在远程仓库创建分支；也可以直接将本地的一个仓库推到远程（本不存在的）分支，分支会被自动创建</li>
</ul>
<p>直接在远程仓库创建分支后要每个人在本地进行一次git pull以获取到远程创建的分支。</p>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
<p>此时git pull的作用是将远程的一个分支<strong>拉取合并</strong>到本地指定的分支上，如果不补全后面的名，则默认将远程分支拉取到本地当前的分支上。</p>
<ul>
<li><strong>本地Feature分支</strong> 如果在远程创建了新的分支，则需要将本地的分支和远程分支建立联系。</li>
</ul>
<p>创建分支后需要将远程的分支和本地的分支进行连接，也就是建立连接关系。使用完整的<code>git pull</code>命令可以直接建立本不存在的连接关系，如果是直接使用git pull可以更新本地仓库，如果已经连接过则可以将代码一同更新。</p>
<p><code>git branch &lt;新分支名&gt; </code>直接创建本地新分支</p>
<p><code>git checkout -b &lt;新分支名&gt; orgin/&lt;远程分支名&gt;</code> 创建本地新分支同时切换到那个分支，同时建立远程分支的连接</p>
<p><code>git push --set-upstream origin &lt;分支名&gt;</code>创建远程分支并将当前的分支推送到远程分支。</p>
<ul>
<li><strong>本地开发</strong></li>
</ul>
<p>每个人在自己的Feature分支上进行开发。</p>
<p><em><strong>单分支和多分支</strong></em></p>
<p>如果是单分支，所有人的代码最后都会被提交到同一个远程Feature分支上，需要经常解决冲突。</p>
<p>如果是多分支，每个人的代码都是单独的一条Feature分支，最后统一合并的时候解决冲突。</p>
<ul>
<li><strong>合并和提交代码</strong></li>
</ul>
<p>一般来说有两种提交方式，一种是将自己的Feature分支推送到远程仓库，然后使用pull request，由管理人员进行Feature合并到master的过程，这个方法比较推荐比较符合开发的理念。</p>
<p>如果是多分支开发，pull request时如果没有冲突就会自动合并分支，如果有冲突则需要先解决冲突。回到本地拉取最新的master，然后将master合并到Feature上，在这里解决冲突，冲突解决之后再将Feature推送到远程仓库，然后进行pull request的合并。</p>
<p>另一种就是将本地的Feature直接和master合并然后进行将master推送到远程。在本地进行合并之前首先将master更新到最新，然后像上面多分支开发一样解决冲突后，将Feature合并到master上，最后再将本地的master推送到远程仓库</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>LightRoom后期照片管理</title>
    <url>/2024/05/12/LightRoom%E5%90%8E%E6%9C%9F%E7%85%A7%E7%89%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>作为一个摄影入门甚至还没有买相机的小白，每次漫展借舍友的相机也要拍coser，现在尝试学习后期。</p>
<p>在这里记录一下我自己根据网上的学习和自己的实际情况，确定除了一套后期照片管理的流程。</p>
<h3 id="一、拍摄并导出"><a href="#一、拍摄并导出" class="headerlink" title="一、拍摄并导出"></a>一、拍摄并导出</h3><p>拍摄后在相机内可以对照片进行分级，然后如果是比较明显的废片比如完全没有对焦、拍到了空地之类的就在拍摄后直接手动删掉，减少后期筛选的强度，毕竟去一次漫展可以拍好几百张的照片再放到后期筛选废片实在是太麻烦。</p>
<p>然后准备进行照片从SD卡内的导出。</p>
<h3 id="二、照片的存储"><a href="#二、照片的存储" class="headerlink" title="二、照片的存储"></a>二、照片的存储</h3><p>目前主要有三个存储位置，一个是宿舍内的NAS，是作为备份和大容量的存储，一个是台式电脑或者笔记本电脑，这两个作为导出照片或者筛选照片的中转，还有一个移动存储设备，目前是有一个256g的固态u盘，打算在不久的将来换成一个移动硬盘扩展坞，方便SD卡的导出以及照片和视频数据的移动。</p>
<p>首先大致的文件管理是，在台式机的机械硬盘上有一个文件夹，这个文件夹以<strong>年&#x2F;月&#x2F;日</strong>的组织方式展开子文件夹。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240512004529782.png"
                      alt="image-20240512004529782"
                ></p>
<p>之后在任意一台设备上使用LightRoom的创建新目录功能，在我的<strong>移动介质</strong>上创建一个以<strong>地点事件</strong>为名的文件夹，之后在LightRoom中从SD卡中进行照片RAW文件的导出，选择拷贝选项将这些照片直接导入到刚刚创建的文件夹下的<strong>源文件</strong>子文件夹，到这里为止一次拍摄的照片简单管理就完成了，现在这个<strong>地点事件</strong>就作为一次摄影中照片管理的最小单位。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240512004634317.png"
                      alt="image-20240512004634317"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240512005034632.png"
                      alt="image-20240512005034632"
                ></p>
<p><em>在导入界面左侧是导入源，右侧是导入目的文件夹，上面是导入的模式</em></p>
<p>上面的操作直接将照片从SD卡进行了导出，导出后就以照片管理的最小单位进行备份，也就是将这个<strong>地点事件</strong>文件夹直接拷贝到台式机电脑的对应文件夹中，在这里台式电脑的对应文件夹并不作为直接的后期工作目录。</p>
<p>然后再通过NAS定期进行台式机上所有文件的备份和整理。</p>
<p><em>在这里建议大家可以学习我的文件夹组织形式，尤其是以一个地点事件中的所有照片作为一个LightRoom目录，并且对这些目录进行整理和备份，一个LightRoom的目录都配有一个LightRoom的<strong>lrcat</strong>文件，这个文件记录了该文件夹下所有文件在LightRoom中的改动。千万不要直接打开LightRoom就直接进行照片的导入和后期，直接导入的话会将照片导入到默认的工作区文件夹下，每次打开LightRoom都会将这些所有照片进行加载，并且所有照片的修改都放在这里并不安全。因为我有多个设备所以使用到移动介质作为工作目录的载体，可以根据自己的实际情况来选择工作目录放在哪里和备份的位置，但是不管怎么样都要进行备份以保证数据安全。</em></p>
<h3 id="三、导出及发布"><a href="#三、导出及发布" class="headerlink" title="三、导出及发布"></a>三、导出及发布</h3><p>在上一步的导入之后，我们就可以每次在任何一个设备上双击lrcat文件来打开工作目录并进行修图。</p>
<p>进行审片时可以通过打分，标注锦旗或者加入到收藏夹中对所有的照片进行更加细致的分级，以便导出时不同的用途。</p>
<p>修图之前，在图库查看照片时，可以在右侧对照片进行一次命名。相机导出时会自带一个照片序号，在这之前加上一些关键词例如人物名或者景点名之类的以便以后查找。</p>
<p>导出时先进行所有照片的一次性导出，以留作照片的备份。</p>
<p>接下来可以在LightRoom中按照照片的分级和分类，进行不同用途的导出。在这里举个例子比如给coser的返图，要分享在社交媒体上的，要放在手机相册中的。</p>
]]></content>
  </entry>
  <entry>
    <title>Makefile详解</title>
    <url>/2024/04/13/Makefile%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一、Makefile是什么"><a href="#一、Makefile是什么" class="headerlink" title="一、Makefile是什么"></a>一、Makefile是什么</h3><p>makefile定义了一些规则来制定项目如何进行编译。</p>
<p>makefile中包含了一系列的**目标(Targets)<strong>和</strong>规则(Rules)**。</p>
<p>目标通常是文件名，并且大概率是.o文件。紧跟着的生成这个文件的规则，通常是其源文件和编译的命令。<strong>编译的命令也可以是能够命令行执行的命令。</strong></p>
<p>除了目标和规则，makefile也可以用来指定编译器的某些行为例如使用哪一个编译器或者编译器优化等级等等。</p>
<h3 id="二、Makefile基础"><a href="#二、Makefile基础" class="headerlink" title="二、Makefile基础"></a>二、Makefile基础</h3><h4 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h4><ul>
<li>makefile文件直接命名为<strong>makefile</strong>才能让make工具识别。</li>
<li>makefile的编写规则为目标+编写规则，在目标名后面加上<code>：</code>就代表这是一个目标的条目</li>
</ul>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo <span class="string">&quot;HelloWorld&quot;</span>\</span><br><span class="line"><span class="comment">#目标名为all,在构建目标时执行echo命令，加上@后在命令行里就不会打印多余的内容</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240409213927459.png"
                      alt="image-20240409213927459"
                ></p>
<ul>
<li><p>如果在同一个makefile中定义了多个目标，然后直接在命令行中执行<code>make</code>命令，就会执行makefile中的第一个目标。当然也可以自己指定要构建的目标。</p>
<h4 id="2、依赖"><a href="#2、依赖" class="headerlink" title="2、依赖"></a>2、依赖</h4><p>依赖是包含在规则中的一部分，如果一个目标依赖于另一个目标，那么就要依次先构建依赖的关系目标，才能构建当前的目标。</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: test</span></span><br><span class="line">	@echo <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="comment">#在构建目标all时，会先构建其先决条件test目标</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240409214548703.png"
                      alt="image-20240409214548703"
                ></p>
<h4 id="3、规则"><a href="#3、规则" class="headerlink" title="3、规则"></a>3、规则</h4><p>一条目标的条目其实也就是一个整个规则，由<strong>目标</strong>、<strong>依赖</strong>和<strong>命令</strong>组成。其中依赖必须在构建该目标之前就已经满足，这个依赖也可以是其他的目标，也就是会被先构建出来才会构建原本的目标。规则的命令需要能够生成出目标，才能被其他目标作为依赖。</p>
</li>
</ul>
<h3 id="三、Makefile的特性"><a href="#三、Makefile的特性" class="headerlink" title="三、Makefile的特性"></a>三、Makefile的特性</h3><h4 id="1、不重复构建"><a href="#1、不重复构建" class="headerlink" title="1、不重复构建"></a>1、不重复构建</h4><p>如果在makefile中以文件作为构建的目标，在执行make的时候就会将对应的文件构建出来，这些文件会一直存在，如果在下一次的构建中这些文件的源文件没有被修改，那么就不会重复构建这些文件。</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#makefile</span></span><br><span class="line"><span class="section">all: main.o helloworld.o</span></span><br><span class="line">        gcc -o main main.o helloworld.o 	<span class="comment">#编译链接出main文件</span></span><br><span class="line">        @echo <span class="string">&quot;Make all&quot;</span></span><br><span class="line"><span class="section">main.o: main.c 						#依赖源文件main.c</span></span><br><span class="line">        gcc -c main.c 				<span class="comment">#编译出main.o</span></span><br><span class="line">        @echo <span class="string">&quot;Make main.o&quot;</span></span><br><span class="line"><span class="section">helloworld.o: helloworld.c 			#依赖源文件helloworld.c</span></span><br><span class="line">        gcc -c helloworld.c 		<span class="comment">#编译出helloworld.o</span></span><br><span class="line">        @echo <span class="string">&quot;Make helloworld.o&quot;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">helloworld</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        helloworld();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//helloworld.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">helloworld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240409222123641.png"
                      alt="image-20240409222123641"
                ></p>
<p>执行了两次make,可以看到后一次make并没有构建目标<code>main.o</code>和<code>helloworld.o</code>，因为前一次make已经生成了这两个文件，并且在后一次make时会自动识别<code>main.c</code>和<code>helloworld.c</code>是否发生了更新时间的变化，也就是是否进行了更改，如果<code>.c</code>源文件没有被更改，make就认为要构建的目标<code>main.o</code>和<code>helloworld.o</code>也是最新的不需要进行重新构建。</p>
<p><em><strong>那为什么all会被重新构建呢？</strong></em></p>
<p>因为构建目标是<strong>all</strong>而不是gcc的目标<strong>main</strong>，main文件已经存在了但是目标all并不存在，关键在于要构建的目标是否存在。</p>
<h4 id="2、假目标"><a href="#2、假目标" class="headerlink" title="2、假目标"></a>2、假目标</h4><p>有时候我们构建出一个目标后，这个目标已经存在那么在进行重新构建时就不会执行任何该目标下的命令。但是有时我们需要该目标下除了<strong>构建这个目标的命令之外的命令</strong>，就需要想办法暂时屏蔽掉<strong>不重复构建的特性</strong>，这时候就可以用到假目标。</p>
<p>​																		<em>不使用假目标的效果</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240409224219548.png"
                      alt="image-20240409224219548"
                ></p>
<ul>
<li>假目标就是为了避免所要构建的目标和已经存在的文件重名的情况。</li>
</ul>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#makefile</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: main.o</span></span><br><span class="line"><span class="section">all: main.o helloworld.o</span></span><br><span class="line">        gcc -o main main.o helloworld.o 	<span class="comment">#编译链接出main文件</span></span><br><span class="line">        @echo <span class="string">&quot;Make all&quot;</span></span><br><span class="line"><span class="section">main.o: main.c 						#依赖源文件main.c</span></span><br><span class="line">        gcc -c main.c 				<span class="comment">#编译出main.o</span></span><br><span class="line">        @echo <span class="string">&quot;Make main.o&quot;</span></span><br><span class="line"><span class="section">helloworld.o: helloworld.c 			#依赖源文件helloworld.c</span></span><br><span class="line">        gcc -c helloworld.c 		<span class="comment">#编译出helloworld.o</span></span><br><span class="line">        @echo <span class="string">&quot;Make helloworld.o&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>使用假目标后，可以进行同意目标的重复构建，此时<code>main.o</code>的构建被单纯的当成一个目标而并非是一个文件，并不会检查此时文件的存在性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240409224235265.png"
                      alt="image-20240409224235265"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>makefile</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Picgo图床搭配阿里云OSS创建个人图床</title>
    <url>/2024/03/25/Picgo%E5%9B%BE%E5%BA%8A%E6%90%AD%E9%85%8D%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p><em><strong>由于写这篇博客时Picgo图床还没有配置好，所以没有插入对应步骤的图片。</strong></em></p>
<h3 id="一、picgo下载"><a href="#一、picgo下载" class="headerlink" title="一、picgo下载"></a>一、picgo下载</h3><p>找到picgo的<strong>github主页</strong>，选择<strong>release发行版</strong>，然后找到适合自己电脑系统的版本进行<strong>下载和安装</strong>。linux版本可以使用<em>appimage</em>文件进行安装，下载<em>appimage</em>文件后，<strong>右键属性</strong>调整为可读写并且作为可执行文件，然后就可以在命令行中直接运行了。（为什么要早命令行中运行呢，因为如果出现问题命令行会报错好解决问题，我这里就出现了一些问题需要我添加一个可选项后缀才能运行。）</p>
<h3 id="二、阿里云OSS配置"><a href="#二、阿里云OSS配置" class="headerlink" title="二、阿里云OSS配置"></a>二、阿里云OSS配置</h3><p>登陆阿里云控制台，点击左侧导航栏选择<strong>对象存储OSS</strong>。</p>
<p>进入OSS存储界面后，选择<strong>创建bucket</strong>，并且购买存储包，然后填写bucket的信息，<strong>地域</strong>就选择自己所在的地域就行，<strong>存储类型</strong>选择标准存储，<strong>同城冗余存储和版本控制</strong>看需求，默认不选。<strong>读写权限</strong>选公共读，剩下的默认就行。</p>
<p>点击右上角自己的头像选择<strong>访问控制</strong>然后点击<strong>用户</strong>，点击<strong>创建用户</strong>，填写必填项后勾选<strong>编程访问</strong>，之后就会出现<strong>AccessKeyID</strong>和<strong>AccessKeySecret</strong>，这两个是十分重要的信息请<em><strong>务必复制保留</strong></em>。勾选自己的用户然后<strong>添加权限</strong>并勾选<strong>对象存储OSS</strong>。</p>
<h3 id="三、图床配置"><a href="#三、图床配置" class="headerlink" title="三、图床配置"></a>三、图床配置</h3><p>打开Picgo图床的主界面选择<strong>左侧阿里云OSS</strong>，然后可能这时候有一个<strong>Default</strong>配置，点击编辑或者添加新的配置。根据刚才复制下来的ID和Secret填入<strong>KeyID和KeySecret</strong>，<strong>存储空间名</strong>填入自己的Bucket名字，<strong>存储区域</strong>要到bucket界面查看，将<strong>aliyun.com前面</strong>的内容加入到存储区域中。剩下的默认即可。<strong>别忘了点击保存和设为默认图床。</strong></p>
]]></content>
      <categories>
        <category>配置记录</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>OriAndBlindForest--一段近乎完美的旅程</title>
    <url>/2024/04/08/OriAndBlindForest-%E4%B8%80%E6%AE%B5%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、奥日初印象"><a href="#一、奥日初印象" class="headerlink" title="一、奥日初印象"></a>一、奥日初印象</h3><p>​		作为一款横版平台动作游戏，在我刚接触时仅仅是对横版游戏的喜爱。在最基础的平台跳跃动作，加上精灵之火自瞄的攻击系统，这显然是一款更侧重跳跃或者其他动作而削弱攻击动作的游戏，仅凭这一点已经让我这个横版游戏爱好者愿意继续上手玩下去。</p>
<p>​		除了最基本的游戏模式外，首先关注到的还有游戏画面。本身奥日的美术风格就十分喜人，偏写实的风格搭配上合适的光影效果，在奇幻的世界中营造出不错的沉浸感，同时色彩的使用也绝不含糊。更加独特的地方是作为一款跳跃平台游戏，除了左右方向和上下方向的实际游戏图层，游戏画面在近景和远景处都额外添加了几层图层，随着角色的左右移动远近视角的透视感也跟着变化，产生了一种独特的立体感。要知道这款游戏可是在2015年发布的“老”游戏，能做到如此唯美的美术风格和超前的游戏画面，我认为是十分难得的，哪怕是放在今天来看，这样的画面依然是同类游戏中的佼佼者。</p>
<p>​		在这样美丽的游戏画面下，我也更愿意在游戏的世界中探索。奥日算是非常典型的银河恶魔城游戏，探索和解谜的成分占据了游戏大部分时间，并且将收集道具变成了收集属性值和经验值，使用经验值来对自己简单能力进行升级，以及收集更加强力的能力来推进游戏的探索。在游戏模式方面我绝对是足够满意的，侧重使用能力及跳跃去解谜而同时也有一些关卡必须进行和精英怪的对战，在对战时往往也需要用到独特的能力，不管是解谜还是对战都始终能够充分发挥我作为一个玩家的想象力和创造力。</p>
<p>​		尽管着优秀的游戏模式，随之而来的就是超高的难度。在我进行游戏的前一个小时里，就死了不下100次。游戏有着独特的存档机制，自己的蓝条多数情况下都是用来</p>
<h4 id="我们自始至终都知道故事是虚构的，但是当我们真正扮演一个角色参与到故事中，依然能够获得独一无二的感动，依然能感受到作者想要传达的感情。"><a href="#我们自始至终都知道故事是虚构的，但是当我们真正扮演一个角色参与到故事中，依然能够获得独一无二的感动，依然能感受到作者想要传达的感情。" class="headerlink" title="我们自始至终都知道故事是虚构的，但是当我们真正扮演一个角色参与到故事中，依然能够获得独一无二的感动，依然能感受到作者想要传达的感情。"></a>我们自始至终都知道故事是虚构的，但是当我们真正扮演一个角色参与到故事中，依然能够获得独一无二的感动，依然能感受到作者想要传达的感情。</h4>]]></content>
      <categories>
        <category>游戏随笔</category>
      </categories>
      <tags>
        <tag>银河恶魔城</tag>
        <tag>横版游戏</tag>
        <tag>美术优秀</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习过程</title>
    <url>/2024/01/20/Python%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、py理解"><a href="#一、py理解" class="headerlink" title="一、py理解"></a>一、py理解</h3><p>py是一种解释型语言，也就是说不需要编译就可以直接运行，类似于PHP和Perl语言</p>
<p>py是交互式语言，可以在命令行中<code>&gt;&gt;&gt;</code>后面直接执行代码</p>
<p>py是面向对象语言，即将程序分为多个对象进行编程，每个对象执行一定的功能，各对象之间联系性低，可维护性高</p>
<p><em><strong>py使用缩进来表示代码块，而不是 <code>&#123;&#125;</code>。</strong></em></p>
<p><em><strong>py使用<code>\</code>来连接多行语句，默认不能换行。</strong></em></p>
<p><em><strong>空行可以用来分隔函数和类，便于代码的维护和重构。</strong></em></p>
<p><em><strong>同一行显示多条语句可以使用分号 <code>;</code> 进行分隔。</strong></em></p>
<p><em><strong>py中不需要像c一样声明变量，只要直接写出变量并给出初始值就行。</strong></em></p>
<h3 id="二、py注释（写注释是一个好习惯）"><a href="#二、py注释（写注释是一个好习惯）" class="headerlink" title="二、py注释（写注释是一个好习惯）"></a>二、py注释（写注释是一个好习惯）</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string"># &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>python有这三种常用的注释。</p>
<h3 id="三、标准数据类型"><a href="#三、标准数据类型" class="headerlink" title="三、标准数据类型"></a>三、标准数据类型</h3><h6 id="（1-Numbers数字"><a href="#（1-Numbers数字" class="headerlink" title="（1 Numbers数字"></a>（1 Numbers数字</h6><p>数字中有<strong>整型</strong>、__浮点型__、<strong>布尔型</strong>、<strong>复数型</strong></p>
<h6 id="（2-String字符串"><a href="#（2-String字符串" class="headerlink" title="（2 String字符串"></a>（2 String字符串</h6><p>字符串用单引号<code>&#39;str&#39;</code>和双引号<code>&quot;str&quot;</code>表示 ，然后可以用三引号表示多行字符串。转义符和c语言中的转义符是一样的都是反斜杠<code>\</code>。</p>
<p>怎么让转义符不生效？在整个字符串前面加上<code>r</code>。连续的字符串可以被自动连接起来，也可以用<code>+</code>表示两个字符串的相连，用乘号<code>*</code>加上次数表示重复。</p>
<p>字符串的最后一个字符不能是反斜杠</p>
<h6 id="（3-List列表"><a href="#（3-List列表" class="headerlink" title="（3 List列表"></a>（3 List列表</h6><h6 id="（4-Tuple元组"><a href="#（4-Tuple元组" class="headerlink" title="（4 Tuple元组"></a>（4 Tuple元组</h6><h6 id="（5-Dictionary字典"><a href="#（5-Dictionary字典" class="headerlink" title="（5 Dictionary字典"></a>（5 Dictionary字典</h6><h3 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt入门</title>
    <url>/2024/02/26/Qt%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>STM32存储架构详解</title>
    <url>/2024/05/08/STM32%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>STM32及ARM中断详解</title>
    <url>/2024/05/08/STM32%E5%8F%8AARM%E4%B8%AD%E6%96%AD%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="ARM体系的中断和异常"><a href="#ARM体系的中断和异常" class="headerlink" title="ARM体系的中断和异常"></a>ARM体系的中断和异常</h4><p>当一个中断或者异常<strong>触发</strong>时，先看到这个中断源有没有被启动，以及它的优先级如何，然后进入<strong>中断向量表</strong>，如果允许进行中断或者异常的处理，就会根据中断向量表进入<strong>中断服务程序</strong>。</p>
<p>在中断服务程序中进行<strong>关中断、保存现场、开中断、处理中断和异常、关中断、恢复现场、开中断</strong></p>
<p>在ARM体系中和异常统一由中断向量表管理。</p>
<h5 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h5><p>中断向量表有低端和高端向量表两种，低端向量表就是从0x00000000开始，高端向量表处在0xFFFF0000位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240508162736933.png"
                      alt="image-20240508162736933"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>SystemView简单移植</title>
    <url>/2024/05/08/SystemView%E7%AE%80%E5%8D%95%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<h4 id="一、SystemView是什么"><a href="#一、SystemView是什么" class="headerlink" title="一、SystemView是什么"></a>一、SystemView是什么</h4><p>SystemView是由SEGGER公司开发的嵌入式系统可视化分析工具，可以用来可视化的监控嵌入式操作系统的运行，帮助我们更好的学习和开发嵌入式操作系统。</p>
<p>SystemView支持uC&#x2F;OS-II、μC&#x2F;OS-III、FreeRTOS、embOS和无OS的裸机系统。</p>
<p>SystemView可以使用串口、J-Link等连接方式和硬件进行连接。</p>
<h4 id="二、SystemView工作模式介绍"><a href="#二、SystemView工作模式介绍" class="headerlink" title="二、SystemView工作模式介绍"></a>二、SystemView工作模式介绍</h4><p>持续记录模式：基于J-Link调试器和SEGGER实时传输技术（RTT），SystemView可以在目标程序运行时实时地记录目标执行情况，不使用J-Link RTT技术，也可以通过串口或者TCP&#x2F;IP实现。</p>
<p>Single-Shot模式：当目标设备不支持RTT或没有使用J-Link时，SEGGER SystemView可以用于记录数据，直到其目标缓冲区被填充满时停止记录。</p>
<p>Post-Mortem模式：类似Single-Shot模式，但会在缓冲区填满时覆盖旧的事件，所以，记录到的是最新的系统活动事件。这个模式可用于分析某些应用突然崩溃的问题，SystemView可以显示系统崩溃前发生的情况。</p>
<p><strong>在这里我们一般都是用持续记录模式，所以并不会做深入的介绍</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240514174143934.png"
                      alt="image-20240514174143934"
                ></p>
<h4 id="三、SystemView工作目录"><a href="#三、SystemView工作目录" class="headerlink" title="三、SystemView工作目录"></a>三、SystemView工作目录</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240509103612862.png"
                      alt="image-20240509103612862"
                ></p>
<p>我们创建了一个SystemView文件夹，里面是Config和Src文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240512181718276.png"
                      alt="image-20240512181718276"
                ></p>
<p>在keil中是这样的文件夹目录，因为keil不支持多级目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240508215739039.png"
                     
                ></p>
<p>在SEGGER提供给我们的SystemView的Src文件夹中有这些内容。</p>
<p>其中</p>
<p>Config文件夹中的是一些RTT实时传输和SystemView的配置。</p>
<p>Sample文件夹中的是一些可用的操作系统的接口文件，需要我们找到需要的接口文件。</p>
<p>SEGGER文件夹中的就是SystemView和RTT的源文件，不需要我们修改，直接放进工程目录中。</p>
<h4 id="四、配置SystemView和RTT以及开启系统追踪功能"><a href="#四、配置SystemView和RTT以及开启系统追踪功能" class="headerlink" title="四、配置SystemView和RTT以及开启系统追踪功能"></a>四、配置SystemView和RTT以及开启系统追踪功能</h4><ul>
<li><strong>os_cfg.h</strong></li>
</ul>
<p>在os_cfg.h中找到宏<strong>OS_TRACE_EN</strong>并将其值改为1，也就是打开系统追踪功能。</p>
<p><strong>OS_TRACE_API_ENTER_EN</strong>和<strong>OS_TRACE_API_EXIT_EN</strong>是系统API调用的监控。</p>
<ul>
<li><strong>os_trace.h</strong></li>
</ul>
<p>要启用系统追踪功能需要将这个头文件包含进去。</p>
<p>在我们的项目中，可以看到这个头文件包含在ucos_ii.h中。</p>
<ul>
<li><strong>os_cfg_trace.h</strong></li>
</ul>
<p>配置宏<strong>OS_CFG_TRACE_MAX_TASK</strong> 和<strong>OS_CFG_TRACE_MAX_RESOURCES</strong>表示可以监控的任务和其他内核对象的最大数量。</p>
<ul>
<li><strong>SEGGER_RTT_Conf.h</strong></li>
</ul>
<p><strong>BUFFER_SIZE_UP</strong>表示缓冲区最大值，给4096</p>
<ul>
<li><strong>SEGGER_SYSVIEW_Conf.h</strong></li>
</ul>
<p>在这里我没找到<strong>SEGGER_SYSVIEW_RTT_BUFFER_SIZE</strong>这个定义的宏，所就自己定义了一个。</p>
<p><code>#define SEGGER_SYSVIEW_RTT_BUFFER_SIZE    4096u</code></p>
<p>也是定义buffer缓冲区的大小。</p>
<ul>
<li><strong>SEGGER_SYSVIEW_Config_uCOSII.c</strong></li>
</ul>
<p>在这里需要更改两个宏函数<strong>SYSVIEW_TIMESTAMP_FREQ</strong>和<strong>SYSVIEW_CPU_FREQ</strong>，这两个宏会被下面的函数<strong>SEGGER_SYSVIEW_Conf</strong>所调用，所以我们需要让这两个宏的值是SYSCLK的值。利用RCC库中的<strong>RCC_GetClocksFreq</strong>函数来获取时钟频率。</p>
<p><strong>SYSVIEW_RAM_BASE</strong>宏定义表示着缓冲区的最低地址，应该不需要更改。 </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SYSCLK_FreqGet</span><span class="params">()</span>&#123;</span><br><span class="line">	RCC_ClocksTypeDef get_rcc_clock;</span><br><span class="line">	RCC_GetClocksFreq(&amp;get_rcc_clock);</span><br><span class="line">	<span class="keyword">return</span> get_rcc_clock.SYSCLK_Frequency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSVIEW_TIMESTAMP_FREQ  (SYSCLK_FreqGet())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSVIEW_CPU_FREQ        (SYSCLK_FreqGet())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSVIEW_RAM_BASE        (0x20000000)</span></span><br></pre></td></tr></table></figure></div>

<p>再往下是中断信息的输出函数，在这里进行输出的更改，在SystemView中想看到具体的中断名称而不仅仅是中断号，就可以在这里进行配置。</p>
<p><strong>例</strong></p>
<p><code>SEGGER_SYSVIEW_SendSysDesc(&quot;I#15=SysTick&quot;);</code></p>
<p><em><strong>到这里为止，我们就对SystemView进行了基本的配置和移植。</strong></em></p>
<p>参考文档：</p>
<p><a class="link"   href="https://micrium.atlassian.net/wiki/spaces/osiidoc/pages/163904/SEGGER+SystemView" >Starting the Trace Recorder - µC&#x2F;OS-II Documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="五、启用SystemView进行追踪"><a href="#五、启用SystemView进行追踪" class="headerlink" title="五、启用SystemView进行追踪"></a>五、启用SystemView进行追踪</h4><p>在主程序中调用OS_TRACE_INIT()函数进行初始化。</p>
<p><em>注意，为了在SystemView的电脑软件中观察到具体的任务，请使用OSTaskNameSet为一个任务设定名称，否则在软件中只能看得到问号。</em></p>
<p><strong>连接硬件配置</strong></p>
<p>我们所使用的STM32F401RE-NUCLEO开发版有板载的ST-Link，SEGGER官方提供了一个<a class="link"   href="https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/" >ST-LINK Reflash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>工具，可以用来把ST-Link变成J-Link来用。跟着其中的教程一步步走，先安装两种Link的驱动，再使用软件将ST-Link变成J-Link。这时候发现J-Link不能直接给板子供电，必须要外接一个供电设备比如另外一个ST-Link。</p>
<p><strong>软件配置</strong></p>
<p>打开SystemView软件，在Target中可以看到Record Configuration，在这里选择J-Link并且自己选择好设备类型，之后就可以开始记录了。</p>
]]></content>
  </entry>
  <entry>
    <title>WPF学习</title>
    <url>/2024/01/20/WPF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>uC/OS移植</title>
    <url>/2024/04/24/uC-OS%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>从零开始的Stm32学习</title>
    <url>/2024/01/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Stm32%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><em><strong>写在前面</strong></em>  <em>原本是跟着江协科技的课入门了stm32f103，但是对stm32的开发还停留在一个比较浅的认知，以及实操水平有限只会使用库函数，所以想通过stm32f401re的学习从头到尾搞明白整个流程，也为将来自己画板子、写启动文件、汇编语言打好基础。</em></p>
<h3 id="一、使用keil进行stm32开发"><a href="#一、使用keil进行stm32开发" class="headerlink" title="一、使用keil进行stm32开发"></a>一、使用keil进行stm32开发</h3><p>刚开始的入门软件是keil，所以这次也打算从keil入手，将keil学明白之后再尝试使用其他的软件和环境进行开发，同时也是使用库函数的方式进行开发。</p>
<p>使用keil中的<strong>pack installer</strong>安装自己要开发的板子的对应版本，然后在意法半导体官网去找相对应的软件包并解压。在官网的导航找到<strong>软件-》微控制器软件-》STM32微控制器软件-》标准外设软件库</strong>，然后选择适合自己的开发板的就可以。</p>
<p>这里我用的是stm32f401re开发板，所以要找stm32f4的软件包，软件包中有对应的启动文件以及库函数，库函数直接对底层硬件进行操作，所以可以提高开发的效率，但是也同样会占用更多的资源（库函数之于直接操作寄存器就好像是高级语言之于低级语言）。在keil中新建工程，并且在对应的文件夹下建立<strong>Libraries</strong>（存放库函数）、<strong>User</strong>（存放自己写的main函数）、<strong>Start</strong>（存放各种启动文件）。</p>
<p><strong>启动文件详解</strong>：1. CMSIS标准中定义了内核函数层，和设备外设访问层，</p>
<h3 id="二、片上外设详解"><a href="#二、片上外设详解" class="headerlink" title="二、片上外设详解"></a>二、片上外设详解</h3><h4 id="1、GPIO（通用输入输出）"><a href="#1、GPIO（通用输入输出）" class="headerlink" title="1、GPIO（通用输入输出）"></a>1、GPIO（通用输入输出）</h4><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231016155952611.png"
                      alt="image-20231016155952611"
                ></p>
<p>从IO引脚进入有两个保护二极管，用来防止电压过高或者电压过低。从IO口进入首先是驱动器，然后是寄存器。</p>
<p>上半部分的驱动器对应输入模式，信号输入首先会有一个上拉和下拉电阻，这里有三种模式可选分别是上拉和下拉和浮空。当输入端没有信号输入时，进入寄存器的高低电平就由此处控制。上拉默认为高电平的输入模式，下拉默认为低电平的输入模式。再向内有一个<strong>肖特基（施密特）触发器</strong>，是一个对输入信号进行整形的装置，当输入的信号高于一个上限时就向内输入高电平，低于下限则输入低电平，用这种方法可以减少数据的抖动。在施密特触发器前后分别接到了模拟输入和复用功能输入上，对应额外的功能。</p>
<p>下半部分的驱动器对应输入模式。可以用数据寄存器进行数据的输出，位设置清除寄存器可以单独操作输出寄存器的某一位但是不影响其他位，一整个数据寄存器控制所有的端口，所以不能直接对某一位进行操作，要使用按位与和按位或的操作，或者直接用位设置清除寄存器。也可以接到复用功能也就是其他片上外设上来获取额外的功能。两个mos管<strong>P_MOS，N_MOS</strong>可以配置推挽（push_pull）和开漏（open_drain）或者关闭。</p>
<h6 id="GPIO的八种工作模式"><a href="#GPIO的八种工作模式" class="headerlink" title="GPIO的八种工作模式"></a>GPIO的八种工作模式</h6><p><strong>1）模拟输入 GPIO_Mode_AIN</strong> 输入模式直接接入模拟输入</p>
<p><strong>2）浮空输入 GPIO_Mode_IN_FLOATING</strong> 上下拉电阻选择浮空输入模式，容易被干扰</p>
<p><strong>3）下拉输入 GPIO_Mode_IPD</strong> 上下拉电阻选择下拉输入模式，默认电平为低，可以用于检测由低到高的电平变化</p>
<p><strong>4）上拉输入 GPIO_Mode_IPU</strong> 上下拉电阻选择上拉输入模式，默认电平为高，可以用于检测由低到高的电平变化</p>
<p><strong>5）开漏输出 GPIO_Mode_OUT_OD ** 上P_MOS不工作，只有下面的N_MOS在工作，可以输出低电平，不能直接输出高电平，要靠外面的上拉电阻。适合用作通讯协议的模式，不会强行输出高电平。</strong><em>可以同时输入输出。</em>**</p>
<p><strong>6）推挽输出 GPIO_Mode_OUT_PP</strong> P_MOS和N_MOS都在工作，可以直接输出高低电平，是一种强推输出模式。<em><strong>可以同时输入输出</strong></em></p>
<p><strong>7）复用开漏输出 GPIO_Mode_AF_OD</strong> GPIO此时连接到片上外设受片上外设控制</p>
<p><strong>8）复用推挽输出 GPIO_Mode_AF_PP</strong> GPIO此时连接到片上外设受片上外设控制</p>
<h6 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h6><h4 id="2、NVIC（嵌套向量中断控制器）"><a href="#2、NVIC（嵌套向量中断控制器）" class="headerlink" title="2、NVIC（嵌套向量中断控制器）"></a>2、NVIC（嵌套向量中断控制器）</h4><p>NVIC是一个内核外设，也就是在芯片内部，但是不同厂家也会对NVIC的功能进行裁切，但是多数情况下的NVIC是差不多的，关于NVIC的定义一般放在<strong>misc.c</strong>和<strong>misc.h</strong>里面。NVIC是用来控制系统异常和外部中断的。</p>
<h6 id="使用NVIC"><a href="#使用NVIC" class="headerlink" title="使用NVIC"></a>使用NVIC</h6><p>首先使能外设某个中断，这个具体由每个外设的相关中断使能位控制。然后要使能NVIC的中断，配置NVIC中断优先级，设置优先级分配组，一共有四位作为优先级，可以将四位分别分配给响应优先级和抢占优先级，使得两种优先级都有一定的范围，接下来使用NVIC的初始化结构体为开启的外设中断通道分配响应优先级和抢占优先级，<em>（响应优先级是中断同时发生时响应优先级高的可以产生中断，抢占优先级是在进行一个中断时另一个抢占优先级高的能够中断抢占优先级低的事件）</em>，然后使用初始化函数初始化NVIC。配置好NVIC和外设的中断之后，接下来要编写中断函数，当外设的中断事件触发时，就可以跳转到自己写的中断函数中。</p>
<h4 id="3、USART"><a href="#3、USART" class="headerlink" title="3、USART"></a>3、USART</h4><h4 id="4、I2C"><a href="#4、I2C" class="headerlink" title="4、I2C"></a>4、I2C</h4><h4 id="5、TIM定时器"><a href="#5、TIM定时器" class="headerlink" title="5、TIM定时器"></a>5、TIM定时器</h4><p>定时器有三种，分别是基本定时器，通用定时器，高级定时器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231113132948740.png"
                      alt="image-20231113132948740"
                ></p>
<p><strong>基本定时器</strong>的基本单元就是时基单元，由<strong>预分频器、计数器和自动重装寄存器</strong>构成，预分频器负责将内部时钟进行分频，自动重装寄存器中存着需要计时的次数，计数器会向上计数，到达自动重装寄存器的数值时重新装填，并且触发触发NVIC的中断，或者跳转到更新事件。可以开启主模式触发DAC，在主模式下计数器触发不会触发中断，会直接触发映射到<strong>TRGO</strong>然后直接输出DAC。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231113133125832.png"
                      alt="image-20231113133125832"
                ></p>
<p><strong>通用定时器</strong>的核心还是时基单元，和基本定时器是一样的。通用定时器和高级定时器支持向下计数和中央对齐模式。通用定时器支持外部时钟驱动，从外部时钟进入的信号经过极性选择、边缘检测和预分频器还有滤波，可以直接作为时基单元的时钟，这一路叫做<strong>外部时钟模式2</strong>。另外的<strong>TRGI</strong>触发输入当做时钟，叫做<strong>外部时钟模式1</strong>。外部时钟可以直接接入TRGI；其他的定时器的TRGO输出也可以接入TRGI，作为定时器的<strong>级联</strong>；也可以从CH1引脚的边沿触发作为输入，类似于输入捕获。</p>
<p>下半部分是输入捕获和输出比较的电路，这两个功能共用一套寄存器，所以同时只能使用其中一种功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231113194330817.png"
                      alt="image-20231113194330817"
                ></p>
<p><strong>高级定时器</strong>的计数器后面还有一个重复次数计数器，计数器满多少个周期后产生输出，也就是一个<em>输出分频器</em>。相比于通用定时器，在下面的输出比较模块多了<strong>DTG</strong>功能，输出多了一个口可以生成PWM的互补波形，用来驱动三相无刷电机。下面还有一个刹车输入，外部引脚产生刹车信号或者外部时钟失效是，就会产生刹车信号自动切断电机的信号。</p>
<p><strong>预分频控制寄存器</strong>不会直接控制分频系数，预分频控制寄存器有一个<strong>缓冲寄存器</strong>，这才是真正起作用的寄存器。改变预分频控制寄存器后，在下一个周期时才会更改缓冲寄存器的值来改变分频系数。自动重装寄存器也有缓冲寄存器，效果是一样的。影子寄存器的作用就是保证数据的更改在同一个周期后更新，防止发生错误。</p>
<p>计数器的<strong>计数频率</strong>就是输入的<strong>时钟频率&#x2F;（分频系数+1）</strong>,计数器溢出的频率<strong>（中断更新频率）</strong>就是<strong>计数频率&#x2F;（自动重装寄存器+1）</strong></p>
<p>定时器的输出可以进入中断输出控制。</p>
<p><em><strong>（1）使用TIM定时器</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231113220608188.png"
                      alt="image-20231113220608188"
                ></p>
<p>要使用定时器就要打通从左到右的全流程。首先时钟的输入源，RCC内部时钟或者ITR其他定时器或者TI的输入捕获通道，通过外部时钟可以选择两个外部时钟模式，ETR引脚的配置需要额外配置一下。配置好输入源之后，可以开始配置时基单元的两个寄存器，然后要配置中断输出控制和NVIC两个东西。最后还要手动启动一下运行控制。</p>
<p><em><strong>（2）输出比较功能Outp Compare</strong></em></p>
<p>输出比较功能可以用来输出PWM信号。使用输入捕获和输出比较寄存器，将<strong>CNT计数器</strong>里面的数字和<strong>CCR捕获比较寄存器</strong>进行对比，然后如果大于或者小于就翻转输出的电平。</p>
<p>调整时基单元的输入，预分频器PSC，ARR自动重装器，可以调整PWM的周期和频率，然后CCR的值和ARR值的比值就是占空比。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231114175347871.png"
                      alt="image-20231114175347871"
                ></p>
<p>输出模式控制器有八种模式。</p>
<ul>
<li>冻结， REF保持原状态</li>
<li>匹配时置有效电平，CNT&#x3D;CCR时，REF置有效电平（高电平）</li>
<li>匹配值置无效电平，CNT&#x3D;CCR时，REF置无效电平（低电平）</li>
<li>匹配时电平翻转，CNT&#x3D;CCR时，REF电平翻转，输出的波形占空比始终为50%</li>
<li>强制有效电平，CNT和CCR无效，REF强制为高电平</li>
<li>强制无效电平，CNT和CCR无效，REF强制为低电平</li>
<li>PWM模式1，向上计数：CNT&lt;CCR时置REF为有效电平，CNT&gt;&#x3D;CCR时置REF为无效电平，向下计数同理。</li>
<li>PWM模式2，向上计数：CNT&lt;CCR时置REF为无效电平，CNT&gt;&#x3D;CCR时置REF为有效电平，向下计数同理。</li>
</ul>
<p>在输出信号后再经过CC1P，这里还可以进行一次极性翻转。最后信号会通向GPIO口。</p>
<p>对于高级定时器，有两个互补的PWM输出端口，用来驱动外面的推挽电路。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/IMG_1117.png"
                      alt="IMG_1117"
                ></p>
<p>这两个互补的端口会分别导通正极和负极，在外面产生一个PWM波形，最高电压就是推挽电路的正极电压。在这两个端口前面还有一个死区生成器，在两个端口切换电平是提供一段时间的死区防止上两个端口接通时间比较接近导致的短路。</p>
<p>要使用PWM首先需要配置TIM定时器，然后配置<strong>输出比较</strong>这一块所有的寄存器，就可以使用PWM了。</p>
<h4 id="6、RCC时钟树"><a href="#6、RCC时钟树" class="headerlink" title="6、RCC时钟树"></a>6、RCC时钟树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20231113201719527.png"
                      alt="image-20231113201719527"
                ></p>
<p>时钟源有四个，分别是内部外部高速低速。外部的是石英震荡器，内部的是RC振荡器，外部时钟更稳定，更常用。 </p>
<ul>
<li><p>HSI高速内部时钟 8MHz</p>
</li>
<li><p>HSE高速外部时钟 4-16MHz</p>
</li>
<li><p>LSE低速外部时钟 32.768kHZ</p>
</li>
<li><p>LSI低速内部时钟 40kHz</p>
</li>
<li><p><strong>PLLMUL</strong>是锁相环，外部高速时钟会经过锁相环倍频，然后进入预分频器。</p>
</li>
<li><p><strong>CSS</strong>用来检测外部时钟是否正常，如果出了问题会自动切换到内部时钟</p>
</li>
<li><p>进入预分频器后，旁路可能会有倍频器来输出72MHz到TIM定时器。</p>
<p>使用外设时钟控制，就可以将外设时钟使能与进时钟输出，也就是启动时钟。</p>
</li>
</ul>
<p>stm32上电后先进行Systeminit，先开启内部高速时钟HSI，然后初始化HSE开始使用HSE作为时钟，然后通过AHB预分频器进行分频</p>
<h3 id="三、通信协议"><a href="#三、通信协议" class="headerlink" title="三、通信协议"></a>三、通信协议</h3><h4 id="1、I2C协议"><a href="#1、I2C协议" class="headerlink" title="1、I2C协议"></a>1、I2C协议</h4><p>同步半双工，带数据应答，支持总线挂载多设备，两条总线：<strong>SCL（时序总线）</strong>，<strong>SDA（数据总线）</strong></p>
<p><strong>硬件I2C</strong>：STM32如果有I2C硬件模块可以直接使用，查手册找一下I2C挂载在何处，然后初始化I2C的各种属性。直接往数据寄存器中写入值发送然后直接从数据寄存器中读取数据。</p>
<p><strong>软件I2C</strong>：可以使用软件函数的方式模拟I2C协议，初始化GPIO口，将一个口的输出作为SCL另一个作为SDA，然后根据I2C的时序特点在不同的时序阶段将数据放在SDA总线上，定时上拉和上拉SCL。</p>
<p><em><strong>时序特点</strong></em>：</p>
<p><strong>1)基本时序单元</strong></p>
<p>​	<strong>产生起始条件：</strong>SCL高电平期间，SDA从高电平切换到低电平</p>
<p>​	<strong>产生终止条件：</strong>SCL高电平期间，SDA从低电平切换到高电平</p>
<p>​	<em>产生起始条件和终止条件都是由主机决定的。</em></p>
<p>​	<strong>主机发送数据：</strong>SCL低电平期间将一位数据放到SDA上后，主机将SCL提到高电平，此时SDA不允许有变化，从而让从机接收数据，高位先行。</p>
<p>​	<strong>主机接收数据：</strong>主机释放SDA将控制权交给从机，主机控制SCL，在低电平期间从机发送数据，在高电平期间主机接收数据</p>
<p>​	<strong>发送应答：</strong>在主机接收完一个字节后，在下一个时钟发送一位数据，数据0表示应答</p>
<p>​	<strong>接收应答：</strong>在主机发送给从机一个字节后，在下一个时钟发送一位数据给主机，主机此时要接受这个数据，数据0表示应答，数据1表示非应答</p>
<p><strong>2)通信时序</strong></p>
<p>​	<strong>指定地址写：</strong>对于指定设备的指定寄存器写入数据。</p>
<p>​	第一个数据帧，七位地址<strong>＋</strong>一位读写位（0写1读），紧跟着就是应答位，从机此时应该给主机接受应答。第二个数据帧，可以是设备的内部寄存器地址，紧跟着应答位。</p>
<p>​	再往后主机可以产生终止条件。</p>
<p>​	<strong>指定地址读：</strong>对指定设备的指定寄存器写入数据。</p>
<p>​	第一个数据帧，七位地址**+<strong>一位读写位（此时写入），然后从机数据应答，第二个数据帧，指定设备的内部寄存器地址，然后从机应答，</strong><em>此时重新产生起始条件</em><strong>，第三个数据帧指定七位地址</strong>+**一个读写位（此时读入），	第四个数据帧就是从机返回给主机的数据。</p>
<p>​	最后主机产生终止条件。</p>
<ol start="3">
<li></li>
</ol>
<h4 id="2、USART协议"><a href="#2、USART协议" class="headerlink" title="2、USART协议"></a>2、USART协议</h4><p>异步全双工，点对点通信，两个引脚<strong>TX和RX</strong>，分别用来发送数据和接收数据，点对点发送数据也就是TX接RX，RX接TX。</p>
<p>波特率是串口通信的速率。</p>
<p><em><strong>时序特点：</strong></em></p>
<p>空闲状态是高电平，每个时序单元的<strong>起始位</strong>是低电平来表示开始传输一个数据帧，<strong>停止位</strong>是一个高电平，也就是重新回到空闲状态。数据帧低位先行。在停止位之前，数据帧之后，可以选择性的添加一个校验位。</p>
<p><em><strong>轮询模式：</strong></em></p>
<h4 id="3、PWM输出信号"><a href="#3、PWM输出信号" class="headerlink" title="3、PWM输出信号"></a>3、PWM输出信号</h4><p>PWM是一种模拟信号，在具有惯性的系统中，对PWM进行调制，就可以等效的获得的模拟量。<strong>PWM频率&#x3D;1&#x2F;T</strong>,<strong>占空比&#x3D;Ton&#x2F;T</strong>也就是每个周期中高电平的时间比上周期的时间，占空比决定模拟输出的电压。<strong>分辨率占空比变化步距</strong>，就是占空比的变化程度。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划背包问题</title>
    <url>/2024/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、0-1背包问题"><a href="#一、0-1背包问题" class="headerlink" title="一、0-1背包问题"></a>一、0-1背包问题</h4><p>现在有一个背包容量为v，有一系列的物品分别有wgt[i]的重量和val[i]的价值。问怎么取物品装到背包里使得总价值最大。</p>
<p>对于每一个物品都有选与不选两种决策，那么对每一个物品进行规划，如果选择了物品，那么可用容量减少但是价值增加。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[n + <span class="number">1</span>][v + <span class="number">1</span>];<span class="comment">//dp数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= wgt[i]) dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - wgt[i]] + val[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="二、0-1背包空间优化"><a href="#二、0-1背包空间优化" class="headerlink" title="二、0-1背包空间优化"></a>二、0-1背包空间优化</h4><p>在01背包中，新dp数值只和上一行相关，所以可以将整体的空间压缩为一行，计算出第一行所有数据之后，计算第二行时要从后往前进行计算。如果从前往后计算，就会提前清除上一行靠前的数据，那么后面的计算就无法使用</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[v + <span class="number">1</span>]; <span class="comment">//dp数组</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//对特定位置置零</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = v; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">		esle&#123;</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= wgt[i]) dp[j] = <span class="built_in">max</span>(dp[j - wgt[i]] + val[i], dp[j]); <span class="comment">//如果能放入就由上一行的前面的数据计算得出结果</span></span><br><span class="line">			<span class="keyword">else</span> dp[j] = dp[j]; <span class="comment">//如果不能放入那么等于原值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="三、完全背包问题"><a href="#三、完全背包问题" class="headerlink" title="三、完全背包问题"></a>三、完全背包问题</h4><p>完全背包和01背包不同之处在于，有无限件可选的物品，也就是说每次进行dp计算时，同一个物品选择后还可以再选一次。但其实整体的思路还是一样的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[n + <span class="number">1</span>][v + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= wgt[i])&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i][j - wgt[i]] + val[i], dp[i - <span class="number">1</span>][j]);<span class="comment">//如果选择了放入物品，那么只有容量变化</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//如果没有选择那么可选物品进行变化</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="四、完全背包空间优化"><a href="#四、完全背包空间优化" class="headerlink" title="四、完全背包空间优化"></a>四、完全背包空间优化</h4><p>完全背包也可以按照01背包类似的思路进行空间优化，但是完全背包的数据不完全来自于上一行数据，也来自于左侧的数据。所以这里采用正序遍历。</p>
<p><em><strong>dp问题的空间优化关键在于新的数据是否能通过确定步数内的数据推导出</strong></em>**</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[v + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//对特定位置置零</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;= v; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= wgt[i]) dp[j] = <span class="built_in">max</span>(dp[j - wgt[i]] + val[i], dp[j]); <span class="comment">//如果选择放入物品，数据只和左侧数据有关</span></span><br><span class="line">			<span class="keyword">else</span> dp[j] = dp[j]; <span class="comment">//如果不选择放入物品，数据就和上一行相同</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="五、多重背包问题"><a href="#五、多重背包问题" class="headerlink" title="五、多重背包问题"></a>五、多重背包问题</h4><p>多重背包问题类似完全背包和01背包的思路，综合两者的思路即可解决。在选择一个物品时进行循环，直到物品被取完或者大于背包容量则停止这个物品的选择进入下一个物品的选择。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库数据结构和字段详解</title>
    <url>/2024/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一、在数据库中创建表"><a href="#一、在数据库中创建表" class="headerlink" title="一、在数据库中创建表"></a>一、在数据库中创建表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>上述代码创建了一个叫做<em>table_test</em>，并创建了<code>int</code>类型的键<em>id</em>，<code>varchar</code>类型长度为10的键<em>name</em>。</p>
<h3 id="二、键的约束"><a href="#二、键的约束" class="headerlink" title="二、键的约束"></a>二、键的约束</h3><h4 id="1、主键约束（primary-key）"><a href="#1、主键约束（primary-key）" class="headerlink" title="1、主键约束（primary key）"></a>1、主键约束（primary key）</h4><p>主键用来唯一标识表中的每一行数据，主键字段不能包含<strong>NULL</strong>值，且每个表只能有一个主键。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key, <span class="comment">--将id设为主键</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>代理键是系统自动生成的不带有特殊意义的可以作为主键的键，在Postgre数据库中可以使用<code>serial</code>创建代理键，并且使用表级约束将代理键设为主键。</p>
<p>代理键会自动从零递增。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id serial <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">constraint</span> id_check <span class="keyword">primary</span> key id</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、唯一约束（unique）"><a href="#2、唯一约束（unique）" class="headerlink" title="2、唯一约束（unique）"></a>2、唯一约束（unique）</h4><p>确保字段的值在整个表中是唯一的，可以为<strong>NULL</strong>，可以单独作为一个约束使用，也可以和主键约束一起使用。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key, <span class="comment">--将id设为主键</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">unique</span> <span class="comment">--使name字段的值唯一</span></span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>也可以使用表级约束定义由多个列组成的复合主键<code>constraint table_test_PK primary key (id,name)</code></p>
<p>复合主键用来将两列不能唯一的列组合起来以构成唯一的列，来确保表中具有能作为主键的列。</p>
<h4 id="3、检查约束（check）"><a href="#3、检查约束（check）" class="headerlink" title="3、检查约束（check）"></a>3、检查约束（check）</h4><p>约定字段的值在一个规定的范围内。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">check</span> (id <span class="operator">&gt;=</span> <span class="number">0</span>) comment <span class="string">&#x27;id&#x27;</span>, <span class="comment">--为字段添加了检查约束使得id必须大于零</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>也可以在表级别进行检查约束，在定义列之后可以加上<code>constraint id_check check (id &gt;= 0)</code>，这个约束名为id_check，并且作用于id字段。</p>
<p>可以使用<strong>enum</strong>枚举类型代替检查约束。</p>
<p>在这里也可以用语句<code>name varchar(10) check (name in (&#39;小明&#39;，&#39;小红&#39;))</code>达到一样的效果。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    name enum(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>) <span class="comment">--限制name只能取值为两个枚举量</span></span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="4、默认约束（default）"><a href="#4、默认约束（default）" class="headerlink" title="4、默认约束（default）"></a>4、默认约束（default）</h4><p>指定一个字段的默认值。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;id&#x27;</span> ,<span class="comment">--id默认值为0</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="5、非空约束（not-null）"><a href="#5、非空约束（not-null）" class="headerlink" title="5、非空约束（not null）"></a>5、非空约束（not null）</h4><p>约束一个字段的值不能为空。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;id&#x27;</span>, <span class="comment">--值不能为空</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)comment <span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="6、外键约束（foreign-key"><a href="#6、外键约束（foreign-key" class="headerlink" title="6、外键约束（foreign key)"></a>6、外键约束（foreign key)</h4><p>外键约束使得一个字段的取值必须来自于另一个表的特定字段（通常是主键）。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    city_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (city_id) <span class="keyword">REFERENCES</span> cities(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>以上的代码对<strong>city_id</strong>添加了约束使得其值只能是<strong>city</strong>表中的<strong>id</strong>取值。</p>
<h3 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h3><p>数据库有三种数据结构</p>
<h4 id="1、数值类型"><a href="#1、数值类型" class="headerlink" title="1、数值类型"></a>1、数值类型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240403110650691.png"
                     
                ></p>
<ul>
<li>在数值类型后面加上<strong>unsigned</strong>表示无符号</li>
<li>在浮点类型后面加上括号指定两个参数，一个是位数一个是小数位。</li>
</ul>
<h4 id="2、字符串类型"><a href="#2、字符串类型" class="headerlink" title="2、字符串类型"></a>2、字符串类型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240403111118041.png"
                     
                ></p>
<ul>
<li><p>在字符串后面加上括号指定字符长度</p>
</li>
<li><p><strong>char</strong>是定长字符串，性能好但是空间大，<strong>varchar</strong>是变长字符串，性能差但是空间小。</p>
</li>
<li><p><strong>blob</strong>是二进制文件，一般不用。<strong>text</strong>是二进制文本。</p>
</li>
</ul>
<h4 id="3、时间日期类型"><a href="#3、时间日期类型" class="headerlink" title="3、时间日期类型"></a>3、时间日期类型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240403201151186.png"
                      alt="image-20240403201151186"
                ></p>
<h3 id="四、字段额外属性"><a href="#四、字段额外属性" class="headerlink" title="四、字段额外属性"></a>四、字段额外属性</h3><ul>
<li><strong>comment</strong>可以给某一个字段添加注释，也可以给表添加。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和内存与缓存的关系</title>
    <url>/2024/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="一、常见的内存相关函数"><a href="#一、常见的内存相关函数" class="headerlink" title="一、常见的内存相关函数"></a>一、常见的内存相关函数</h3><p><em><strong>C语言库函数，来自stdlib</strong></em></p>
<h4 id="1、malloc"><a href="#1、malloc" class="headerlink" title="1、malloc"></a>1、malloc</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<p>分配指定大小的内存空间，并且返回一个指向该内存起点的指针。</p>
<h4 id="2、calloc"><a href="#2、calloc" class="headerlink" title="2、calloc"></a>2、calloc</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<p>分配指定内存大小的空间，前一个参数是内存的个数，后一个是每个单元的大小。<code>calloc</code>和<code>malloc</code>区别在于<code>calloc</code>会将所有的内存单元初始化为<strong>0</strong>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>内存和缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言实验</title>
    <url>/2024/04/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="一、Debug的使用"><a href="#一、Debug的使用" class="headerlink" title="一、Debug的使用"></a>一、Debug的使用</h3><ul>
<li><p>-r查看寄存器</p>
</li>
<li><p>-r ax 改变ax寄存器的值</p>
</li>
<li><p>-d 加内存地址 查看内存</p>
</li>
<li><p>-d 连续查看内存地址</p>
</li>
<li><p>-e 加<strong>内存地址</strong>加 <strong>值</strong> 修改内存中的内容</p>
</li>
<li><p>-a 加<strong>地址</strong> 使指令指针寄存器指向指定的地址，并且在接下来的指令中可以将指令写入地址中</p>
</li>
<li><p>-t 单步执行</p>
</li>
<li><p>-u 加<strong>地址</strong>将内存地址中的机器码变成汇编语言</p>
</li>
</ul>
<h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3><p><strong>CS + IP</strong>构成了指令的地址</p>
<p>通用寄存器可以分为高八位和低八位，如果计算结果越界，高位会被直接省略掉，如果是在高八位或者低八位中单独越界，<strong>低八位的进位也不会进到高八位中</strong></p>
<h4 id="MUL乘法指令"><a href="#MUL乘法指令" class="headerlink" title="MUL乘法指令"></a>MUL乘法指令</h4><p>使用mul乘法指令时，可以使用两个8位的数相乘，也可以使用两个16位。</p>
<p>如果是8位，第一个乘数默认放在al中，如果是16位第一个乘数默认放在ax中。</p>
<p><strong>如果结果超过8位结果默认放在ax中，如果结果超过16位，高位结果放在dx中，低位结果放在ax中。</strong></p>
<p><strong>mul指令一般不将立即数作为操作数（ARM和8086都是）</strong></p>
<h4 id="DIV除法指令"><a href="#DIV除法指令" class="headerlink" title="DIV除法指令"></a>DIV除法指令</h4><p><strong>除数</strong>可以是8位也可以是16位，<strong>被除数</strong>是16位或者32位，根据被除数来确定。</p>
<p>被除数如果是16位就存放在AX中，如果是32位就存放在DX和AX中。</p>
<p>也就是说<strong>被除数</strong>到底是多少根据<strong>除数</strong>来决定</p>
<h4 id="AND与运算指令"><a href="#AND与运算指令" class="headerlink" title="AND与运算指令"></a>AND与运算指令</h4><p>and 后面可以有两个操作数，结果就是两个数相与的结果</p>
<h4 id="OR指令"><a href="#OR指令" class="headerlink" title="OR指令"></a>OR指令</h4><p>和and类似</p>
<h3 id="三、汇编语言中segment"><a href="#三、汇编语言中segment" class="headerlink" title="三、汇编语言中segment"></a>三、汇编语言中segment</h3><h4 id="DATA数据段"><a href="#DATA数据段" class="headerlink" title="DATA数据段"></a>DATA数据段</h4><p>也就相当于c语言中所有的变量存储的段，不管是有没有初始值都可以存储在这里。</p>
<p>声明变量时需要指定变量的长度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">···</span><br><span class="line">DATA ENDS</span><br></pre></td></tr></table></figure></div>

<h4 id="CODE代码段"><a href="#CODE代码段" class="headerlink" title="CODE代码段"></a>CODE代码段</h4><p>代码段中定义了真正要执行的代码，通常会有一个进入函数标签<strong>START</strong>或者**_START<strong>，在Windows系统中是</strong>main<strong>或者</strong>_main<strong>，这里是程序的入口，在整个汇编代码的最后，要写上</strong>end start**来表示start是程序入口。</p>
<p>为了让汇编器知道我们代码中的程序段就是cs段寄存器，数据段就是ds段寄存器，需要使用一个伪指令<code>assume cd:code, ds:data</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">	START:</span><br><span class="line">		MOV AX, DATA ;将</span><br><span class="line">		MOV DS, AX</span><br><span class="line">	···</span><br><span class="line">	</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START ;表示程序入口</span><br></pre></td></tr></table></figure></div>

<h3 id="二、80x86"><a href="#二、80x86" class="headerlink" title="二、80x86"></a>二、80x86</h3><p>8086汇编代表了x86汇编语言，编写汇编语言时往往使用<strong>大写</strong>。</p>
<p>8086是16位，基于8086系列有80386的32位，寄存器都是16位。<br><strong>通用寄存器</strong> </p>
<ul>
<li>AX 累加寄存器</li>
<li>BX 基址寄存器</li>
<li>CX 计数寄存器</li>
<li>DX 数据寄存器</li>
</ul>
<p><strong>地址指针寄存器</strong> </p>
<ul>
<li>SP 堆栈寄存器</li>
<li>BP 基址指针寄存器</li>
</ul>
<p><strong>变址寄存器</strong> </p>
<ul>
<li>SI 源变址寄存器</li>
<li>DI 目标变址寄存器</li>
</ul>
<p><strong>段寄存器</strong></p>
<ul>
<li>CS 代码段</li>
<li>DS 数据段</li>
<li>ES 附加段</li>
<li>SS 堆栈段</li>
</ul>
<h4 id="段寄存器的意义"><a href="#段寄存器的意义" class="headerlink" title="段寄存器的意义"></a>段寄存器的意义</h4><p><strong>段地址x16 + 偏移地址 &#x3D; 物理地址</strong></p>
<p>段地址就是<strong>段寄存器中的值</strong>，偏移地址就<strong>是地址指针寄存器</strong>和<strong>变址寄存器</strong></p>
<p>CS+IP &#x3D; 执行代码的位置</p>
<p>SS+SP&#x3D;堆栈中的位置</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li><code>shl ax, 6</code>左移几位</li>
<li><code>shr ax, 6</code>右移几位</li>
<li><code>rol ax, 2</code>循环左移</li>
<li><code>ror ax, 2</code>循环右移</li>
<li><code>inc ax</code> ax++</li>
<li><code>dec ax</code> ax–</li>
<li><code>nop</code> 空指令</li>
<li><code>xchg ax,bx</code> 交换两个寄存器</li>
<li><code>neg ax</code> 取负数</li>
<li><code>word ptr[]</code> 强制转换字节和字，word可以换成byte</li>
</ul>
<h4 id="三、ARM汇编"><a href="#三、ARM汇编" class="headerlink" title="三、ARM汇编"></a>三、ARM汇编</h4><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p>伪指令并不是真正的arm指令。</p>
<ul>
<li><p><strong>.text</strong> 意味着接下来的段是代码段，作用和<code>area code</code>类似</p>
</li>
<li><p><strong>.global</strong> 全局定义一个标签</p>
</li>
<li><p><strong>.type</strong> 指定一个标签的类型，常用于指定一个标签是函数</p>
</li>
<li></li>
<li><p><code>RSB R1, R0, #0</code> 将ro的值与0相减，并将值变成r1，也就是将值变成负数</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法与数据结构</title>
    <url>/2024/01/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h3><ul>
<li><em>排序算法中经常会用到交换两个数的值的操作，这个操作可以用位运算实现</em></li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>二分法：怎么分？<em>middle</em> 在哪不重要，关键在于对比后赋值，小于<em>middle</em>则直接赋值<em>middle - 1</em>，大于<em>middle</em>则直接赋值<em>middle + 1</em>。</li>
</ul>
<p>以下是二分查找的代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>; <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     while(left &lt;= right)&#123;</span></span><br><span class="line"><span class="comment">        int middle = left + (right - left) / 2;</span></span><br><span class="line"><span class="comment">        if(nums[middle] &lt; target)&#123;</span></span><br><span class="line"><span class="comment">            left = middle + 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            right = middle - 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return left;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//循环到结束一定会得到left = right，而且middle也等于left，此时的target就在left左、右，或者就是left。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>排序算法的稳定性：<em>如果一个排序算法不改变相同数据之间的相对位置，那么这个排序算法具有稳定性。稳定性对于基本数字类型来说是没有用的，但是对于自己创建的数据类型来说是有用的，在不同维度的排序下不会改变每一条数据的相对位置。</em>跨越数据进行交换的排序不具有稳定性，相邻的进行交换时具有稳定性，非交换的排序不具有稳定性。</li>
</ul>
<p><strong>冒泡、插入、归并</strong>三种排序具有稳定性，要让归并排序具有稳定性需要优先将左侧的数组放进临时数组中。</p>
<ul>
<li>排序算法的选择：对于归并排序和快排来说，两者都使用了分治和递归的思想，而在递归的过程中需要将大问题拆分成小问题，在数据规模较大时直接使用这两种排序比较快，但是在递归到小问题时往往使用其他的排序能减少实际运行时间。<em><strong>排序算法的优化</strong></em></li>
</ul>
<h4 id="1、选择排序"><a href="#1、选择排序" class="headerlink" title="1、选择排序"></a>1、选择排序</h4><ul>
<li><strong>代码思路：</strong>首先选择最左侧的一个数字，将他与剩下的N-1个数字一一对比寻找N个数字中最大（或者最小值），每次对比时将大的（小的）与最左侧的数字交换，然后逐一对比后就能最终找到最值并将其放在最左侧。接下来选择左侧的第二个数字，按照同样的方法与剩下的N-2个数字进行对比，就找到了N-1个数字里的最值。这样对N-1个数字后，所有的数字就全部排列好了。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                arr[i] = arr[i] ^ arr[j];</span><br><span class="line">                arr[j] = arr[i] ^ arr[j];</span><br><span class="line">                arr[i] = arr[i] ^ arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>时间复杂度</strong> N的平方</li>
</ul>
<p>+++</p>
<h4 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h4><ul>
<li><strong>代码思路：</strong>每次都从最左边两个数字开始，每次两个数字进行对比，将比较大的值向右移，一轮过后就将所有数字中的最大值找到并移到最右边了。然后用同样的方法在剩下的N - 1个数字中找到最大的，将它移到右起第二位数字上。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = size; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h4><ul>
<li><strong>代码思路：</strong>从前往后划分区间，先将1到2区间上排好序，然后将3移进，使得1到3区间有序，重复下去一直到1到N区间上有序。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--)&#123;</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h4><ul>
<li><strong>代码思路：</strong>先分治，利用二分法将所有的数字分成两部分，然后将两部分分别进行排序后，进行两部分的合并，合并过程中再次进行排序，利用递归排序然后不断合并。合并时将两个数组排序到一个临时数组中，从两个数组第一个开始取数，小的数拿到临时数组中，直到一个数组到头，就将另外一个数组全部放入临时数组，最后将临时数组赋给这一段的原数组。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> L, <span class="type">int</span> Mid, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* index = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (R - L + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> p1 = L;</span><br><span class="line">    <span class="type">int</span> p2 = Mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= Mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        index[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= Mid)&#123;</span><br><span class="line">        index[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        index[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = i - <span class="number">1</span> ;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        index[i] = arr[L + i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归分治函数</span></span><br><span class="line"><span class="type">void</span> process(<span class="type">int</span> *arr, <span class="type">int</span> L, <span class="type">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>(R == L) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> Mid = L + (R - L)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    process(*arr, L, Mid);</span><br><span class="line">    process(*arr, Mid, R);</span><br><span class="line">    merge(arr, L, Mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>小和问题：</strong>一个数组里每个数左侧比自己小的数加起来的和等于多少。其实也就是一个数右侧比自己大的数有几个，就要自身加几次。那么使用归并排序，在合并的时候可以计算右侧比自己大的数有几个，并且合并时优先将右侧的数字放进临时数组。</li>
</ul>
<p>时间复杂度N logN，额外空间复杂度为N，可以通过代码实现空间复杂度为1。</p>
<h4 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h4><ul>
<li><p><strong>荷兰国旗问题：</strong>选定一个数字作为依据划分一个数组，在数组中左边都是小于这个数字的，中间都是等于这个数字的，右边都是大于这个数字的。从头遍历数组，先从头开辟一块 <em>小于块</em> ，再从后面开辟一块 <em>大于块</em> ，遍历数组时对每个数字进行对比，如果小于就和 <em>小于块</em> 的下一位数字交换并扩大 <em>小于块</em> 的范围，如果大于就和 <em>大于块</em> 的前一位数字进行交换并扩大 <em>大于块</em> 的范围，如此反复遍历直到便利指针指到 <em>大于块</em> 的前一位。</p>
</li>
<li><p><strong>代码思路：</strong>在一个数组中 <em>随机</em> 选定一个数字，将这个数字和数组末尾交换，然后根据这个数字进行 <em>荷兰国旗划分</em> ，划分后就得到了前中后三块，中间的数字固定，分别对前后两块进行同样的递归划分。如此递归下去知道每一个最小分块都是一种数字并且和前后的块具有顺序。</p>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">    arr[b] = arr[a] ^ arr[b];</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换两个数，不允许下标相同</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = rand() % (R - L + <span class="number">1</span>) + L; <span class="comment">//生成0到size - 1的随机数</span></span><br><span class="line">    <span class="type">int</span> p1 = L - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p2 = R;</span><br><span class="line">    <span class="type">int</span> i = L;</span><br><span class="line">    <span class="keyword">if</span> (temp != R) swap(arr, temp, R);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[R])&#123;</span><br><span class="line">            p2--;</span><br><span class="line">            <span class="keyword">if</span>(i != p2) swap(arr, i, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[R])&#123;</span><br><span class="line">            p1++;</span><br><span class="line">            <span class="keyword">if</span>(i != p1) swap(arr, i, p1);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意处理边界问题</span></span><br><span class="line">    swap(arr, p2, R);</span><br><span class="line">    QuickSort(arr, L, p1);</span><br><span class="line">    QuickSort(arr, p2 + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意：在边界指针和遍历指针移动时，要注意指针重合的问题，指针重合时不要进行两个数字的交换，并且此时已经达到跳出循环的边界。</li>
</ul>
<p>快速排序选择划分数字时使用的是随机数，也就是说等概率的取到接近中间值的数，等概率的取到最好情况，时间复杂度为 N*log N，使用递归会开辟额外空间，空间复杂度是log N。</p>
<h4 id="6、基数排序"><a href="#6、基数排序" class="headerlink" title="6、基数排序"></a>6、基数排序</h4><ul>
<li><strong>代码思路：</strong>先取出所有数字的个位根据各位放进对应的桶中，然后按照进桶的顺序出桶，然后以十位做相同的操作，以此类推直到完成最大数字的最高位的进桶出桶。</li>
<li><strong>进出桶：</strong>使用一个 <em>count</em>数组表示这个桶里面有几个数字，从前向后遍历每一个数的特定位，然后将数字符合的进入桶，也就是 <em>count</em> 数组加一，全部遍历完成后进行前缀和操作，将 <em>count</em> 数组每一位变成前面所有数的和。然后进行出桶时从后向前遍历，每一个数的特定位的对应的 <em>count</em> 数减去1就是这个数在这轮排序后的位置。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RedixSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> radix = MaxBits(Max(arr, size));</span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* help = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>; d &lt;= radix; d++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            count[getDigit(arr[i],d)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = size - <span class="number">1</span>; i  &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            help[count[getDigit(arr[i], d)] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[getDigit(arr[i], d)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            arr[i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从辅助数组中拿出来放回原数组进行下一次排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中用到的函数有Max()最大值函数</span></span><br><span class="line"><span class="comment">//Maxbits()传入一个值找到这个值的有多少位</span></span><br><span class="line"><span class="comment">//getDigit()找到一个数的特定位是多少</span></span><br></pre></td></tr></table></figure></div>



<h4 id="7、堆（Heap）排序"><a href="#7、堆（Heap）排序" class="headerlink" title="7、堆（Heap）排序"></a>7、堆（Heap）排序</h4><p>堆结构就是用数组实现的完全二叉树结构，在完全二叉树中如果每棵子树的最大值都是在顶部就是 <em>大根堆</em> 反之就是 <em>小根堆</em>。</p>
<p><em>完全二叉树：</em>总是先有左子树后有右子树，如果有右子树则必有左子树。</p>
<p>左孩子：left &#x3D; index * 2 + 1, 父节点：(left - 1) &#x2F; 2</p>
<ul>
<li><strong>大根堆插入：</strong>将一个数据放到当前的最后一个位置，然后与自己的父节点对比，如果大于自己的父节点，那么和自己的父节点进行交换。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapInsert</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">		swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    	index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>堆化：</strong>将一个数据放到任意一个位置，并且将整个堆变成大根堆的形式。 时间复杂度 log N。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> index, <span class="type">int</span> Heapsize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(left &lt; Heapsize)&#123;</span><br><span class="line">        <span class="type">int</span> largest = index;</span><br><span class="line">        <span class="keyword">if</span>(left + <span class="number">1</span> &lt; Heapsize) &#123;</span><br><span class="line">            largest = arr[largest] &lt; arr[left + <span class="number">1</span>] ? left + <span class="number">1</span> : largest;</span><br><span class="line">        &#125;</span><br><span class="line">        largest = arr[largest] &lt; arr[left] ? left : largest;</span><br><span class="line">        <span class="keyword">if</span>(largest == index) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        left = largest * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>代码思路：</strong>使用<em>HeapInsert</em>将数组输入到一个大根堆中，将堆的第一个值（最大值）和最后一个值进行交换，然后Heapsize减小一个，即最大值在最后位置并且脱离堆，然后对刚才交换到根节点的值进行<em>Heapify</em>使得整个堆重新成为大根堆。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Heapsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Heapsize &lt; size)&#123;</span><br><span class="line">        HeapInsert(arr, Heapsize);</span><br><span class="line">        Heapsize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Heapsize &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --Heapsize);</span><br><span class="line">        Heapify(arr, <span class="number">0</span>, Heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --Heapsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>时间复杂度 N log N，空间复杂度1，不占用额外空间。</p>
<ul>
<li><strong>距离为k的数组排序：</strong>确定一个规模为k的堆，这个堆内的排序会很简单，然后将第k + 1个数拿进堆继续排序。</li>
</ul>
<h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><h4 id="1、数组-Array-和链表-LinkList"><a href="#1、数组-Array-和链表-LinkList" class="headerlink" title="1、数组(Array)和链表(LinkList)"></a>1、数组(Array)和链表(LinkList)</h4><p><strong>数组</strong>空间效率高，支持时间复杂度为1的访问元素，但是缺点也很明显，插入与删除效率很低，而且长度不可变，如果开的数组比较大还会额外浪费空间。</p>
<ul>
<li>数组是存放在连续内存空间上的相同数据类型的集合，内存空间的地址是连续的。二维数组的内存地址也是连续的。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//初始化数组为0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>数组插入元素时，需要将对应位置后面的所有元素向后移，时间复杂度是O(n)。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= pos; i++)&#123;</span><br><span class="line">        a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;	</span><br><span class="line">    a[pos] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数组删除元素时，和插入类似，将删除位置之后的所有元素向前移，时间复杂度相同。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dlete</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> size, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; size - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实相当于对应位置的元素被覆盖掉</span></span><br></pre></td></tr></table></figure></div>

<p><strong>链表</strong>也是一种顺序表，能够利用离散的内存空间，每个元素节点之间通过指针引用的方式相互连接。</p>
<p><strong>单向链表</strong>可用于实现<em>栈、队列、哈希表、图</em>等数据结构。在链表的同一端进行插入和删除时，表现为栈；在链表的两端进行插入和删除操作时，表现为队列。链式结构可用于解决哈希冲突。图中的每一个顶点代表着一个链表，链表中的元素是与这个顶点相连的所有的点。</p>
<p><strong>双向链表</strong>用于快速查找前后的元素，结构体中有两个指针，一个指向前一个元素另一个指向后一个元素，可以进行两个方向的遍历，使得寻找元素更加快速，但是占用了更多的空间。。</p>
<p><strong>环形链表</strong>用于需要周期性操作的场景，最后一个元素节点指向第一个元素节点，使用环形链表时，要使得链表中至少有一个元素，头指针就指向这个元素。。</p>
<p>链表起始位置有一个头指针HeadNode，HeadNode没有数据，只有一个指向下一个节点的指针。</p>
<p>在头指针后面可以有一个头结点，头结点也是没有数据，为了方便某些操作所以引入头结点。接下来的代码中都是没有头结点的。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype; <span class="comment">//元素的类型，可以把int改成所需要的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">//状态指示，作为函数的返回值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建链表节点的结构体，结构体中有该节点的数据和指向下一个节点的指针，构造函数给数据赋值，使指针为空。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	Elemtype data;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(Elemtype x) : <span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>要<strong>创造一个链表</strong>其实就是创建一个头指针来代表一整个链表，使用函数创造一个数据为任意值的节点作为头指针。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">CreatList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ListNode *HeadNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> HeadNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>链表的插入</strong>分为头插法、尾插法和指定位置插入。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">Status <span class="title">InsertByHead</span><span class="params">(ListNode *HeadNode, Elemtype Data)</span></span>&#123;</span><br><span class="line">    ListNode *NewNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(Data);</span><br><span class="line">    NewNode-&gt;next = HeadNode-&gt;next;</span><br><span class="line">    HeadNode-&gt;next = NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法将自己指向下一个节点，然后将头指针指向自己</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">Status <span class="title">InsertByTail</span><span class="params">(ListNode *HeadNode, Elemtype Data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!HeadNode) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果头指针指向空意味着链表中没有元素</span></span><br><span class="line">    </span><br><span class="line">    ListNode *NewNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(Data);</span><br><span class="line">    ListNode *p = HeadNode;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个遍历指针，从头指针开始遍历，如果下一个节点为空，那么此时遍历到的节点就是整个链表的最后一个节点</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定位置插入</span></span><br><span class="line"><span class="function">Status <span class="title">InsertByPosition</span><span class="params">(ListNode *HeadNode， Elemtype Data, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span>(!HeadNode) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果头指针指向空意味着链表中没有元素</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode *NewNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(Data);</span><br><span class="line">    ListNode *p = HeadNode;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; i &lt; pos - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//在链表的范围内没有这个位置，返回-1错误</span></span><br><span class="line">    NewNode-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行指定位置插入是，需要找到插入位置的前一位，所以循环的条件是pos - 1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>链表的删除</strong>，这里只介绍指定位置删除，其他任何删除条件都和指定位置删除类似，只是寻找指定位置的条件不同。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定位置删除</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(ListNode *HeadNode, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!HeadNode) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果链表为空，则直接返回</span></span><br><span class="line">    </span><br><span class="line">    ListNode *p = HeadNode; <span class="comment">//指向被删除位置的前一个节点</span></span><br><span class="line">    ListNode *q = HeadNode-&gt;next; <span class="comment">//指向被删除的位置</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; i &lt; pos <span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果寻找到的被删除位置为空则直接返回</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//链接被删除位置的前后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点关键是使用双指针遍历，用两个指针保存节点的关系才能保证被删除节点的前后关系</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>链表的遍历（查找）</strong>类似于指定位置的操作，指定位置的条件变为查找的条件即可。</li>
</ul>
<h4 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表</h4><p>列表是一个抽象数据结构，具有无限大的容量，可以基于数组（一般不）和链表实现。</p>
<p>列表其实就是动态数组，在不同的编程语言中都有基于动态数组的列表，Python中<code>list</code>，Java中<code>ArrayList</code>，C++中的<code>Vector</code>和c#中的<code>List</code>。</p>
<p>关于动态数组的一些操作，可以观看<a href="/2024/02/10/Cpp%E4%B8%ADvector%E7%9A%84%E7%94%A8%E6%B3%95/"><strong>《C++中Vector的应用》</strong></a>那篇博客。</p>
<h4 id="3、哈希表（Hash）"><a href="#3、哈希表（Hash）" class="headerlink" title="3、哈希表（Hash）"></a>3、哈希表（Hash）</h4><p>哈希表是一种顺序表，可以用来迅速判断一个元素是否在表中。</p>
<p>哈希表建立索引<em>key</em>和值<em>value</em>之间的关系构成一张表，可以通过任给一个key快速地找到value。在哈希表中进行增删改查的时间复杂度都是常数级别，用空间换时间。</p>
<p>哈希函数通过将<em>key</em>映射到存储桶中，以实现在桶中的快速搜索。往往使用大量的空间，使得一个<em>key</em>只对应一条数据。</p>
<ul>
<li><strong>C++实现哈希表</strong> c++中提供了三种set和三种map</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map[<span class="number">12836</span>] = <span class="string">&quot;小哈&quot;</span>;</span><br><span class="line">map[<span class="number">15937</span>] = <span class="string">&quot;小啰&quot;</span>;</span><br><span class="line">map[<span class="number">16750</span>] = <span class="string">&quot;小算&quot;</span>;</span><br><span class="line">map[<span class="number">13276</span>] = <span class="string">&quot;小法&quot;</span>;</span><br><span class="line">map[<span class="number">10583</span>] = <span class="string">&quot;小鸭&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">string name = map[<span class="number">15937</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.<span class="built_in">erase</span>(<span class="number">10583</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历哈希表 */</span></span><br><span class="line"><span class="comment">// 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv: map) &#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用迭代器遍历 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = map.<span class="built_in">begin</span>(); iter != map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>c语言实现哈希表</strong> 一般使用数组结构存储。</li>
</ul>
<p>如果不能够一一对应，就会出现哈希冲突，解决哈希冲突的方法</p>
<h4 id="4、二叉树-BinaryTree"><a href="#4、二叉树-BinaryTree" class="headerlink" title="4、二叉树(BinaryTree)"></a>4、二叉树(BinaryTree)</h4><p>二叉树是一种非线性的数据结构，每个节点可以包含自己的值，左节点和右节点。二叉树可以充分发挥分支的思想，分别从左右子树进行操作，能够减少一些操作的时间复杂度。当二叉树为完美二叉树时，能充分发挥二叉树的时间优势，在极端情况下二叉树可能成为链表，即每一个节点都只具有一个子节点。</p>
<p><strong>完美二叉树</strong>又被称为<strong>满二叉树</strong>，树的每一层都是满的。</p>
<p><strong>完全二叉树</strong>只有最底层的节点没有被填满，且最底层的节点从左向右填满。</p>
<p><strong>完满二叉树</strong>除了叶节点之外，所有的节点都具有两个子节点。</p>
<p>**二叉搜索树(BST)<strong>是一个有序树，若左子树不为空那么左子树上的所有值都小于根节点，右子树则反之，所有的值大于根节点。</strong>平衡搜索树(AVL)**是二叉搜索树的一种，左右子树的高度之差不超过1。</p>
<p><em>如下图右边的树就不是平衡搜索树</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240408200431963.png"
                      alt="image-20240408200431963"
                ></p>
<ul>
<li><strong>数据结构定义</strong></li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    Elemtype data; <span class="comment">//数据</span></span><br><span class="line">    TreeNode *leftchild; <span class="comment">//左孩子</span></span><br><span class="line">    TreeNode *rightchild; <span class="comment">//右孩子</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(Elemtype x): <span class="built_in">data</span>(x), <span class="built_in">leftchild</span>(<span class="literal">NULL</span>),<span class="built_in">rightchild</span>(<span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>创建根节点</strong></li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建二叉树的根节点</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">createBinaryTree</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    TreeNode *RootNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br><span class="line">    <span class="keyword">return</span> RootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>层序遍历</strong> 也就是**广度优先遍历(BFS)**，对树的每一层进行遍历，一层全部遍历完成后再进行下一层的遍历。</li>
</ul>
<p><em>进行广度优先遍历经常使用队列(queue)数据结构</em></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Elemtype&gt; <span class="title">levelOrderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;Elemtype&gt; val;</span><br><span class="line">    queue&lt;TreeNode*&gt; queue;<span class="comment">//借助队列数据结构进行遍历</span></span><br><span class="line">    queue.<span class="built_in">push</span>(root); </span><br><span class="line">    <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node = queue.<span class="built_in">front</span>();<span class="comment">//从队列中取出第一个</span></span><br><span class="line">        val.<span class="built_in">push_back</span>(node-&gt;data); <span class="comment">//取出这个节点的数据</span></span><br><span class="line">        queue.<span class="built_in">pop</span>();<span class="comment">//出队列</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;leftchild != <span class="literal">NULL</span>) queue.<span class="built_in">push</span>(node-&gt;leftchild);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;rightchild != <span class="literal">NULL</span>) queue.<span class="built_in">push</span>(node-&gt;rightchild);</span><br><span class="line">        <span class="comment">//先后入队左右孩子</span></span><br><span class="line">    &#125;<span class="comment">//直到队列为空</span></span><br><span class="line">    <span class="keyword">return</span> val;<span class="comment">//返回所有的取值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>深度优先遍历(DFS)</strong> 在树中有三种遍历次序，两种实现方法。可以进行先序遍历、中序遍历和后序遍历，只是遍历的顺序有所不同。也有两种实现方式分别是递归和迭代，递归就是自己编写递归函数自己调用自己，迭代是借用栈的数据结构。</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归法实现深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//空节点就直接返回，递归的归</span></span><br><span class="line">    <span class="comment">//root-&gt;data对root节点的数据进行访问</span></span><br><span class="line">    <span class="comment">//例如打印或者放入全局变量中或者添加一个参数传入数组</span></span><br><span class="line">    <span class="built_in">preOrderTraversal</span>(root-&gt;leftchild);</span><br><span class="line">    <span class="built_in">preOrderTraversal</span>(root-&gt;rightchild);</span><br><span class="line">    <span class="comment">//先序遍历中先访问根节点数据然后访问左右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//空节点就直接返回</span></span><br><span class="line">    <span class="built_in">inOrderTraversal</span>(root-&gt;leftchild);</span><br><span class="line">    <span class="comment">//root-&gt;data对root节点的数据进行访问</span></span><br><span class="line">    <span class="comment">//例如打印或者放入全局变量中或者添加一个参数传入数组</span></span><br><span class="line">    <span class="built_in">inOrderTraversal</span>(root-&gt;rightchild);</span><br><span class="line">    <span class="comment">//中序遍历中先访问左节点然后是根节点最后是右节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//空节点就直接返回</span></span><br><span class="line">    <span class="built_in">postOrderTraversal</span>(root-&gt;leftchild);</span><br><span class="line">    <span class="built_in">postOrderTraversal</span>(root-&gt;rightchild);</span><br><span class="line">    <span class="comment">//root-&gt;data对root节点的数据进行访问</span></span><br><span class="line">    <span class="comment">//例如打印或者放入全局变量中或者添加一个参数传入数组</span></span><br><span class="line">    <span class="comment">//后序遍历在访问左右子树后再访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代法实现深度优先遍历</span></span><br><span class="line"><span class="function">vector&lt;Elemtype&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;Elemtype&gt; val;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack; <span class="comment">//借助栈结构进行遍历</span></span><br><span class="line">    stack.<span class="built_in">push</span>(root); <span class="comment">//将根节点压栈</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node = stack.<span class="built_in">pop</span>(); <span class="comment">//直接弹出进行根节点的遍历</span></span><br><span class="line">        val.<span class="built_in">push_back</span>(node);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;rightchild) stack.<span class="built_in">push</span>(root-&gt;rightchild);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;leftchild) stack.<span class="built_in">push</span>(root-&gt;leftchild);</span><br><span class="line">        <span class="comment">//先压入右孩子才能保证左孩子先出栈</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h3><p>动态规划（Dynamic Programming）是一种编程的思路，将一个大型的问题分解为若干个更小的子问题，并且在这些子问题中寻找最优的子结构，子问题最终就汇成了大问题的答案。</p>
<p>找到重叠子问题，使用记忆化搜索将计算过的子问题的结果存储起来，需要计算时就看这个结果是否被计算过直接拿来使用。单纯的记忆化搜索或者回溯是一个自顶向下的问题，动态规划则是一个自下而上的问题，从子问题开始使用备忘录进行记录，一直到最大问题。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mem[<span class="number">10</span>]; <span class="comment">//创建备忘录数组</span></span><br><span class="line"><span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="built_in">sizeof</span>(mem)); <span class="comment">//将数组初始化为不可能为结果的数字，表示这个值没有被计算过</span></span><br><span class="line"><span class="keyword">if</span>(mem[i] &gt; <span class="number">0</span>) dp[i] = mem[i]; <span class="comment">//如果调用dp[i]时已经存在过备忘录中，也就是值不为负一，直接调用mem[i]</span></span><br><span class="line"><span class="keyword">else</span> dp[i] = <span class="built_in">fdp</span>(i); <span class="comment">//如果不存在就进行递归的计算，计算后还要将结果存入到备忘录中</span></span><br></pre></td></tr></table></figure></div>

<p><strong>动态规划问题的特征：</strong>先观察是否符合回溯的<em>决策树模型</em>，也就是在每一个决策点产生一种状态。</p>
<p>其次包含最大、最优之类的问题；每一种状态都可以用有限的矩阵和列表表示出来。</p>
<ul>
<li><strong>二维动态规划化成一维</strong>：在一个二维的动态规划中，如果推算一个状态时，他的上一列或者上一行状态已经被完全推算出来，并且这个状态只依赖于上一行或者上一列，（即推算不依赖于更前面的状态）那么可以将上一行或者上一列状态所用的一维数组的空间来存放这个状态。</li>
</ul>
<h4 id="1、0-1背包问题"><a href="#1、0-1背包问题" class="headerlink" title="1、0-1背包问题"></a>1、0-1背包问题</h4><p>现在有<strong>n</strong>件物品，背包的容量为<strong>m</strong>，每一件物品都有自己的价值**v[i]<strong>和重量</strong>w[i]**，尽可能的将物品放进背包内从而使得所携带的物品总价值最高。</p>
<ul>
<li><strong>代码思路：</strong>利用一个二维的dp数组，表示在背包容量为<strong>x</strong>时挑选前<strong>y</strong>件物品时最大的价值，对于每一件物品都有两个选择，一个是拿另一个是不拿。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理（补充知识版）</title>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h4 id="一、数据的二进制表示"><a href="#一、数据的二进制表示" class="headerlink" title="一、数据的二进制表示"></a>一、数据的二进制表示</h4><p>计算机中的所有数据都是由二进制数表示的，基本上都是使用<strong>二进制补码</strong>来表示。数据可以分为<strong>有符号数</strong>和<strong>无符号数</strong>，区分后进行运算会相对简单。</p>
<p>对于<strong>原码</strong>，就是将十进制数转化成二进制数，如果是<strong>负数</strong>的话最高位为一。</p>
<p>对于<strong>反码</strong>，如果是<strong>负数</strong>就将其绝对值的原码每个位都取反，<strong>正数</strong>的反码和原码相同。</p>
<p>对于<strong>补码</strong>，现在计算机体系中主要使用的就是补码，补码将正负数统一的表示，并且使用同一套加法电路就可以完成加法和减法操作。<strong>负数</strong>的补码是其<strong>反码</strong>加一，正数的补码和原码相同。</p>
<ul>
<li><strong>补码的正负数转换：</strong>十进制的一个对正负数，表示为补码后，只要将其中一个的<strong>所有位取反然后加一</strong>就可以变为它的相反数。在进行减法运算的时候可以用到，因为进行减法运算使用的依然是<strong>加法器</strong>，将减法变成<strong>加上</strong>一个数的<strong>相反数</strong>就可以。</li>
</ul>
<h4 id="二、存储硬件"><a href="#二、存储硬件" class="headerlink" title="二、存储硬件"></a>二、存储硬件</h4><p>计算机体系结构中大致包括两部分存储，一部分是<strong>RandomAccessMemory</strong>也就是RAM，另一部分是<strong>ReadOnlyMemory</strong>也就是ROM。</p>
<h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>RAM一般又分为两种，一种是<strong>SRAM（静态）</strong>另一种是<strong>DRAM（动态）</strong>，都是断电不能保存数据的。</p>
<p>SRAM一般被用来作为CPU的缓存，只要一直通电就可以保持数据的稳定，访问速度快造价高容量小。</p>
<p>DRAM一般作为计算的内存，需要通电进行刷新保持数据稳定，速度相对较低造价相对较第容量相对较大。</p>
<p><strong>ROM</strong></p>
<p>ROM最大的特点是断电可以保存数据，虽然是只读存储器，但是现在的ROM可以泛指外存，也就是可重复读写的存储器。</p>
<p><strong>EEPROM</strong> <strong>E</strong>lectrically <strong>E</strong>rasable <strong>P</strong>rogrammable <strong>R</strong>ead <strong>O</strong>nly <strong>M</strong>emory，带电可擦可编程只读存储器。是可更改的只读存储器（ROM），其可通过高于普通电压的作用来擦除和重写。</p>
<p><em>常用于存放硬件设置数据，如PC的BIOS。</em></p>
<p><strong>OTP</strong> <strong>O</strong>ne <strong>T</strong>ime <strong>P</strong>rogrammable，一次性可编程存储器。数据写入后，将不可再次更改和清除。</p>
<p><em>常用于写入产品和安全信息。</em></p>
<p><strong>FLASH</strong>  <strong>Flash</strong>是一种<strong>块Block</strong>擦写型存储器。Flash不像RAM一样需要电源支持才能保存，但又像RAM一样可重写。在某个级别的低电压下，Flash的内部信息可读不可写，类似于ROM，而在较高的电压下，其内部信息可以更改和删除，又类似于RAM。现代的硬盘一般使用flash技术。</p>
<p><em>现代的单片机一般使用Flash作为ROM存储</em></p>
]]></content>
  </entry>
  <entry>
    <title>ARM处理器汇编语言</title>
    <url>/2024/04/08/ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h4 id="Thumb状态切换"><a href="#Thumb状态切换" class="headerlink" title="Thumb状态切换"></a>Thumb状态切换</h4><p>Thumb是16位指令的状态，可以使用16位指令，在进行切换时不会改变通用寄存器。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;现在是ARM指令集</span><br><span class="line">MOV R0,#1 ;将1放进r0寄存器</span><br><span class="line">BX R0 ;跳转的最低位是1，ARM指令集下地址最低位都是0，也就是从ARM指令集跳到Thumb指令集</span><br><span class="line"></span><br><span class="line">;现在是Thumb指令集</span><br><span class="line">MOV R0,#0 ;将0放进r0寄存器</span><br><span class="line">BX R0 ;跳转的最低位是0，Thumb指令集下地址最低位都是1，也就是从Thumb指令集跳到ARM指令集</span><br></pre></td></tr></table></figure></div>

<p>16位Thumb地址一般位于奇数地址，所以跳转到1就进入了Thumb状态。</p>
<h4 id="ARM工作模式切换"><a href="#ARM工作模式切换" class="headerlink" title="ARM工作模式切换"></a>ARM工作模式切换</h4><ul>
<li><strong>用户模式（Usr）</strong> 最普通的模式，资源和指令都受限</li>
</ul>
<p>接下来的都是<strong>特权模式</strong>，可以对<strong>CPSR</strong>寄存器所有的位<strong>直接</strong>进行读写，而用户模式只能进行<strong>间接访问</strong>，如使用<strong>MRS指令</strong>将CPSR寄存器读入另一个寄存器。</p>
<ul>
<li><p><strong>系统模式（Sys）</strong> 特权模式，和用户模式共用一套寄存器但是权限更高</p>
</li>
<li><p><strong>一般中断模式（IRQ）</strong> 通用的中断模式。<em>IRQ异常响应时进入该模式</em></p>
</li>
<li><p><strong>快速中断模式（FIQ）</strong> 用来处理优先级更高的中断 。<em>FIQ异常响应时进入该模式</em></p>
</li>
<li><p><strong>管理模式（SVC）</strong> CPU<strong>上电后默认</strong>的模式，用来做系统的初始化。<em>系统复位或开机、软中断时进入到该模式</em></p>
</li>
<li><p><strong>终止模式（ABT）</strong> 用户程序访问非法地址或者没有权限的地址时会进入。</p>
</li>
<li><p><strong>未定义模式（UND）</strong> CPU在译码阶段不能够识别指令时会进入未定义模式</p>
</li>
</ul>
<p>除了系统模式之外的5种特权模式，都是<strong>异常模式</strong>，异常模式只有在对应的异常发生时才会进入对应的模式。</p>
<p>在发生异常或者中断时，会有一个异常向量表或者中断向量表</p>
<p>+++</p>
<h4 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h4><p>ARM一共有37个用户可见寄存器。</p>
<h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul>
<li><strong>R0-R15</strong> 全模式下可用，其中<strong>R13</strong>是<strong>SP堆栈指针</strong>，<strong>R14</strong>是<strong>LR链接寄存器</strong>，<strong>R15</strong>是<strong>PC寄存器</strong>。</li>
<li><strong>R13_SVC、R14_SVC</strong> 管理模式专用寄存器</li>
<li><strong>R13_ABT、R14_ABT</strong> 终止模式专用寄存器</li>
<li><strong>R13_UND、R14_UND</strong> 未定义模式专用寄存器</li>
<li><strong>R13_IRQ、 R14_IRQ</strong> 中断模式专用寄存器</li>
<li><strong>R8_FIQ~R14_FIQ</strong> 快速中断模式专用寄存器，<em>为了减少保护寄存器使用的时间而进行快速中断，直接多几个专用寄存器</em></li>
</ul>
<h5 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h5><ul>
<li><strong>CPSR</strong>当前程序状态寄存器，具有四位<strong>条件标志位</strong>，两位<strong>中断屏蔽</strong>（包含快速中断），一位<strong>当前工作状态</strong>。</li>
</ul>
<p>最后五位是处理器工作模式。可以通过修改这五位进行工作模式的改变。</p>
<ul>
<li>CPSR的条件标志位：</li>
</ul>
<p><strong>N（Negative）</strong>是否为负数，N&#x3D;1就代表结果为负数。</p>
<p><strong>Z（Zero）</strong> Z&#x3D;1表示运算的结果为零。</p>
<p><strong>C（Carry）</strong> <strong>加法</strong>指令中结果产生了进位，则C&#x3D;1，反之则为0；<strong>减法</strong>指令中发生了<strong>借位</strong>则C&#x3D;0，没有借位则为1；<strong>移位</strong>操作中，C是最后被移出的位。</p>
<p><strong>V（Overflow）</strong> 在有符号数的加减法指令中，发生了符号位溢出，则V&#x3D;1</p>
<ul>
<li><strong>SPSR</strong> 分别对应五种异常模式，五种异常模式发生时可以用来<strong>记录CPSR的值</strong>，然后跳转到对应的异常模式后再使用CPSR。</li>
</ul>
<p>在通用寄存器中<strong>R0-R12是完全的通用寄存器</strong>，不会被用来做特殊用途，所有的针对普通寄存器的指令都可以用于他们。</p>
<h5 id="特殊寄存器的操作"><a href="#特殊寄存器的操作" class="headerlink" title="特殊寄存器的操作"></a>特殊寄存器的操作</h5><ul>
<li><strong>R13（SP）</strong></li>
</ul>
<p>往后看，有堆栈寻址的详细解释。堆栈往往用来实现函数跳转等操作。</p>
<ul>
<li><strong>R14（LR）</strong></li>
</ul>
<p>执行<strong>BL、BLX</strong>指令时，会将<strong>PC-4</strong>（也就是要执行的下一条指令）的值<strong>自动</strong>记录到LR中，以便函数返回时将LR的值送回PC。但是在其他跳转时并不会自动记录，而是需要手动记录PC-4并存储。</p>
<p>一般可以这样用，也就是进行多重嵌套时，将LR压栈才能进入下一层嵌套，回到上一层嵌套就将寄存器出栈。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMFD SP!, &#123;&lt;registers&gt;, LR&#125;</span><br><span class="line">LDMFD SP!, &#123;&lt;registers&gt;, PC&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>在处理异常时</strong>会将异常处理的返回地址放在<strong>对应模式下</strong>的LR寄存器中，但是这个<strong>返回地址</strong>应该是发生异常代码的下一条代码也就是<strong>PC+4</strong>，而在返回时应该去执行<strong>发生异常时正在执行的那条代码</strong>，因为那条代码并没有执行完，也就需要<strong>LR减去一个偏移量</strong>。<em><strong>在发生异常时，所有的跳转地址都是自动配置好的，不需要我们程序员来关心。</strong></em></p>
<ul>
<li><strong>R15（PC）</strong></li>
</ul>
<p>​	arm采用了三级流水线的结构，每一条指令的执行都会经过<strong>取指</strong>、<strong>译码</strong>、<strong>执行</strong>三个阶段，所以正在执行的代码往后两条指令是正在取指的代码，也就是说PC的值是<strong>当前正在执行</strong>的代码<strong>地址+8</strong>。</p>
<p>+++</p>
<h4 id="ARM存储器体系"><a href="#ARM存储器体系" class="headerlink" title="ARM存储器体系"></a>ARM存储器体系</h4><p>ARM的存储器支持大端模式和小端模式，默认是小端模式，也就是数据的低位存储在低地址内存单元中。</p>
<p>ARM处理器的ROM一般是FLASH，所有程序都存储在FLASH中，分为片内和片外两种。</p>
<p>ARM外设有统一的存储器映射编址，也就是访问对应的内存单元就可以访问特定外设的寄存器。这些内存地址不会被缓存。</p>
<p><em><strong>STM32存储架构详解</strong></em></p>
<p>+++</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>ARM汇编指令遵循着相对固定的格式，如**&lt; opcode &gt; {&lt; cond &gt;} {S}&lt; Rd &gt;，&lt; Rn &gt; {，&lt; OP2 &gt;}**。</p>
<p>在其中</p>
<ul>
<li><strong>opcode</strong>就是指令的<strong>操作码</strong>的助记符，例如ADD、MOV。</li>
<li><strong>cond</strong>是可选的<strong>条件执行</strong>，可以是EQ、NE等，满足条件则执行这条指令，条件就是一个CPSR的标志位。</li>
<li><strong>S</strong>也是一个可选的指令，就是S，表示是否刷新CPSR中的条件标志位。如果不使用就仍是原来的值。</li>
<li><strong>Rd、Rn</strong>分别代表第一个操作数和第二个操作数。</li>
<li><strong>OP2</strong>表示可选的第三操作数。</li>
</ul>
<p><strong>条件执行的条件码和对应的条件</strong></p>
<ul>
<li>EQ    <strong>Z&#x3D;1</strong>    相等</li>
<li>NE    <strong>Z&#x3D;0</strong>    不相等</li>
<li>CS&#x2F;HS    <strong>C&#x3D;1</strong>    无符号数大于或者等于</li>
<li>CC&#x2F;LO    <strong>C&#x3D;0</strong>    无符号数小于</li>
<li>MI    <strong>N&#x3D;1</strong>    负数</li>
<li>PL    <strong>N&#x3D;0</strong>    正数或者零</li>
<li>VS    <strong>V&#x3D;1</strong>    溢出</li>
<li>VC    <strong>V&#x3D;0</strong>    未溢出</li>
<li>HI    <strong>C&#x3D;1且Z&#x3D;0</strong>    无符号数大于</li>
<li>LS    <strong>C&#x3D;0或Z&#x3D;1</strong>    无符号数小于或等于</li>
<li>GE    <strong>N&#x3D;V</strong>    带符号数大于或等于</li>
<li>LT    <strong>N!&#x3D;V</strong>    带符号数小于</li>
<li>GT    <strong>Z&#x3D;0且N&#x3D;V</strong>    带符号数大于</li>
<li>LE    <strong>Z&#x3D;1或N!&#x3D;V</strong>    带符号数小于或等于</li>
<li>AL    <strong>无条件执行</strong></li>
<li>NV    <strong>（ARMV3之前）从不执行</strong></li>
</ul>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><ul>
<li><strong>立即数寻址</strong> <strong>arm汇编一般在立即数前面加上#，x86汇编不需要加</strong></li>
<li><strong>寄存器寻址</strong> 寄存器中的值直接作为操作数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV r1, r2 ;将r2的值传到r1</span><br><span class="line">ADD r1, r2, r3 ;将r2的值加上r3的值并赋给r1</span><br><span class="line">MOV r2, r1, LSL #3 ;将r1&lt;&lt;3位并赋给r1</span><br><span class="line">ADD r3, r2, r1, LSL #3 ;将r1&lt;&lt;3 + r2赋给r3</span><br><span class="line">ADD r3, r2, r1, LSL r0 ;将r1&lt;&lt;r0 + r2赋给r3</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>寄存器间址</strong> 寄存器中的值作为内存地址，使用内存地址上的数据作为操作数。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR r1, [r2] ;以r2中的内存地址加载数据进r1</span><br><span class="line">STR r1, [r2] ;将r1中的值写入r2寄存器中的内存地址</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>基址寻址</strong> 使用寄存器中的地址生成新地址并且寻址，一般用于查表和数组访问。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R1, [R0, #2]			;（前变址，不修改基址）将R0中的值加2作为新地址</span><br><span class="line">LDR R1, [R0, #2]!			;（自变址，修改基址）从r0 + 2的位置加载完数据后，R0寄存器的值会增加2。</span><br><span class="line">LDR R1, [R0, R2]			;（前变址，不修改基址）将R0+R2作为新地址</span><br><span class="line">LDR R1, [R0, R2, LSL #2]	;（前变址，不修改基址）将R0+R2&lt;&lt;2作为新地址</span><br><span class="line">LDR R1, [R0], #2			;（后变址，修改基址）从r0的位置加载完数据后，R0寄存器的值会增加2。与上述第二条不同。</span><br><span class="line">STR R1, [R0, #-2]			;（前变址，不修改基址）将R0中的值减2作为新地址。</span><br><span class="line">STR R1, [R0], #-2			;（后变址，修改基址）将R0中的值作为地址，将R1中的值写入该地址，然后R0寄存器值减2</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>多寄存器寻址</strong> STM&#x2F;LDM指令完成多个寄存器的寻址</li>
<li><strong>堆栈寻址</strong> 一般使用<code>STMFD SP! &#123;R0-R3&#125;</code>这样的指令进行寻址，最后SP指向栈顶元素。</li>
</ul>
<h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><p><strong>基础指令</strong></p>
<ul>
<li>ADD 加法运算</li>
<li>MOV 将一个值从一个<strong>寄存器</strong>传入另一个<strong>寄存器</strong>，或者将立即数传入一个寄存器</li>
<li>SUB 减法运算</li>
<li>RSB 反向减法运算</li>
<li>ADC 带<strong>进位</strong>的加法运算，多用来进行大数的加法运算</li>
<li>SBC 带<strong>借位</strong>的减法运算，减法会减去（1-C）进行借位操作，多用来进行大数的减法运算</li>
<li>RSC <strong>反向</strong>的带<strong>借位</strong>减法运算</li>
<li>CMP 两数相减<strong>不保存结果</strong>只更新<strong>条件标志位</strong></li>
<li>CMN 两数相加<strong>不保存结果</strong>只更新<strong>条件标志位</strong>，常用于反向比较两个数，将其中一个数取负数进行比较</li>
<li>MUL 将<strong>寄存器</strong>中的有符号数值相乘，并且只保留低32位到一个寄存器中</li>
<li>MLA 和MUL类似但是将乘法的结果<strong>加上</strong>第三个寄存器的值</li>
<li>UMULL <strong>高精度</strong>的<strong>无符号数乘法</strong>，将结果存储到两个寄存器中</li>
<li>UMLAL <strong>高精度</strong>的<strong>无符号加和乘法</strong>，将结果加和到两个寄存器</li>
<li>SMULL 高精度的<strong>有符号</strong>数乘法</li>
<li>SMLAL 高精度的<strong>有符号</strong>加和乘法</li>
</ul>
<p><strong>位操作指令</strong></p>
<ul>
<li>LSL 逻辑左移，空位补零</li>
<li>LSR 逻辑右移，空位补零</li>
<li>ASL 算数左移，空位补零</li>
<li>ASR 算数右移，<strong>空位根据符号来补0或1</strong></li>
<li>ROR 循环右移，<strong>将最右侧的位移到最左侧</strong></li>
<li>RRX 循环右移，将CPSR中<strong>进位标志位</strong>放在最高位并将最低位移进<strong>进位标志位</strong></li>
<li>MVN 按位<strong>取反</strong>然后移入到通用寄存器</li>
<li>AND 按位与</li>
<li>ORR 按位或</li>
<li>EOR 按位异或</li>
<li>TST 按位与但是<strong>不保存结果</strong>只更新<strong>条件标志位</strong></li>
<li>TEQ 按位异或但是<strong>不保存结果</strong>只更新<strong>条件标志位</strong></li>
<li>BIC 按位清零</li>
</ul>
<p><strong>操作内存指令</strong></p>
<p><em>当偏移地址为非字对齐时，会自动舍弃掉不满一个字的部分。半字同理</em></p>
<ul>
<li>LDR 从<strong>内存</strong>中取得数据传入<strong>寄存器</strong></li>
<li>STR 向<strong>内存</strong>中写入数据</li>
<li>LDRB 从内存中读取一个<strong>字节</strong>写入寄存器并且<strong>空位补零</strong></li>
<li>STRB 向内存中写入一个<strong>字节</strong></li>
<li>LDRSB 从内存中读取一个<strong>字节</strong>写入寄存器并且<strong>空位按符号扩展</strong></li>
<li>LDRH 从内存中读取一个<strong>半字</strong>写入寄存器并且<strong>空位补零</strong></li>
<li>STRH 向内存中写入一个<strong>半字</strong></li>
<li>LDRSH 从内存中读取一个<strong>半字</strong>写入寄存器并且<strong>空位按符号扩展</strong></li>
<li>LDM 从<strong>内存</strong>中取得数据放到<strong>多个寄存器</strong>中</li>
<li>STM 将<strong>多个寄存器</strong>的输入写入到<strong>内存</strong>中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDMIA R0, &#123;R1-R5&#125; ;以ro为基址读取五个数据单元加载到r1-r5</span><br><span class="line">STMIA R6, &#123;R1-R5&#125; ;以r6为基址，将r1-r5的数据写入</span><br></pre></td></tr></table></figure></div>

<p>多寄存器寻址和堆栈寻址时，需要加上不同的后缀，向不同的寻址。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">IA 操作后递增</span><br><span class="line">IB 操作前递增</span><br><span class="line">DA 操作后递减</span><br><span class="line">DB 操作前递减</span><br></pre></td></tr></table></figure></div>

<p>堆栈寻址时，堆栈指针指向的是栈顶元素就是<strong>满栈</strong>，堆栈指针指向栈顶元素的下一个元素就是<strong>空栈</strong>。</p>
<p>每入栈一个元素，<strong>栈指针SP</strong>都会往栈增长的方向移动一个存储单元。如果栈指针SP从高地址往低地址移动，那么这个栈就是递减栈；如果栈指针SP从低地址往高地址移动，那么这个栈就是递增栈，ARM处理器使用的一般都是<strong>满递减堆栈</strong>。</p>
<p><em><strong>SP！代表着在操作之后递增SP指针。</strong></em></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">FA 满递增堆栈</span><br><span class="line">FD 满递减堆栈</span><br><span class="line">EA 空递增堆栈</span><br><span class="line">ED 空递减堆栈</span><br><span class="line">STMFD SP! &#123;R0,R1,R2&#125; ;会自动将高位寄存器先入栈</span><br><span class="line">LDMFD SP！ &#123;R0,R1,R2&#125; ;按照相对应的顺序出栈</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>MRS 从<strong>特殊寄存器</strong>中取数据到一个<strong>普通寄存器</strong></p>
</li>
<li><p>MSR 从<strong>普通寄存器</strong>写入数据到一个<strong>特殊寄存器</strong>，这里的特殊寄存器也就是CPSR</p>
</li>
<li><p>BX，BLX，B，BL四种跳转指令，<strong>带L</strong>的会自动记录PC的值到LR中，<strong>带X</strong>的可以用于跳转Thumb模式。</p>
</li>
</ul>
<h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p><strong>声明全局变量</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GBLA amount ;定义一个全局数字变量，默认值为0</span><br><span class="line">GBLL logic ;定义一个全局逻辑变量，默认值为0</span><br><span class="line">GBLS string ;定义一个全局字符串变量，默认值为null</span><br></pre></td></tr></table></figure></div>

<p><strong>声明局部变量</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LCLA amount ;定义一个局部数字变量</span><br><span class="line">LCLL logic ;定义一个局部逻辑变量</span><br><span class="line">LCLS string ;定义一个局部字符串变量</span><br></pre></td></tr></table></figure></div>

<p><strong>变量赋值</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">amount SETA 10 ;给amount赋值10</span><br><span class="line">logic SETL 1 ;给logic赋值1</span><br><span class="line">string SETS &quot;你好&quot; ;给string赋值&quot;你好&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>定义寄存器列表</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RegList RLIST &#123;R0-R4&#125; ;将R0到R4定义为RegList</span><br><span class="line">STMFD sp!, RegList ;将R0到R4寄存器入栈</span><br></pre></td></tr></table></figure></div>

<p><strong>数据定义</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LTORG ;在代码段最后或者无条件跳转后面或者子程序返回指令，定义数据缓冲池，存储常量信息</span><br><span class="line">	MAP 0x40000000 ;一个段中只能有一个map，定义map的基地址</span><br><span class="line">A FIELD #4 ;定义A占4个字节，A的起始位置就是MAP的地址</span><br><span class="line">B FIELD #4 ;定义B占4个字节，B的起始位置就是MAP加4</span><br><span class="line"></span><br><span class="line">string DCB &quot;hello&quot; ;分配一些字节单元给标号string</span><br><span class="line">DCD ;分配字单元，字对齐</span><br><span class="line">DCDU ;分配子单元，非字对齐</span><br></pre></td></tr></table></figure></div>

<p><strong>程序控制</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF	逻辑表达式</span><br><span class="line">	程序段1</span><br><span class="line">ELSE</span><br><span class="line">	程序段2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line"> 	程序段</span><br><span class="line"> WEND</span><br></pre></td></tr></table></figure></div>

<p><strong>其他伪指令</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALIGN	4,3 ;4个字节对齐并且在上一个位置之后偏移3个字节</span><br><span class="line">AREA 段名,CODE,READWRITE ;段定义</span><br><span class="line">CODE16 ;16位指令</span><br><span class="line">CODE32 ;32位指令</span><br><span class="line">ENTRY ;程序入口</span><br><span class="line">END ;</span><br><span class="line">EXPLORT ;和GLOBAL一样，向外部声明</span><br><span class="line">IMPORT ;引入其他源文件中的符号并加入符号表</span><br><span class="line">EXTERN ;引入其他源文件中的符号但是如果没有调用，就不会加入符号表</span><br><span class="line">EQU ;将常量和标号等效另一个名字</span><br><span class="line">GET ;和INCLUDE一样，包含源文件</span><br><span class="line">ADR ;取一个标号的地址，在非字对齐255字节之内，字对齐1020之内</span><br><span class="line">ADRL ;和ADR一样但是范围不同，在非字对齐64k之内，字对齐256k之内</span><br><span class="line">LDR ;取地址，但是后面要加一个=，全局范围读取</span><br></pre></td></tr></table></figure></div>

<p><strong>宏</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">	MACRO</span><br><span class="line">$MyMacro MacroName $value1,$value2</span><br><span class="line">	LDR R1,#3</span><br><span class="line">	LDR R0,#0</span><br><span class="line">$MyMacro.LOOP</span><br><span class="line">	SUB R1,#1</span><br><span class="line">	CMP R1,R0</span><br><span class="line">	BGT LOOP</span><br><span class="line">	MEND</span><br></pre></td></tr></table></figure></div>

<p><strong>运算符</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x + y ;相加</span><br><span class="line">x - y ;相减</span><br><span class="line">x * y ;相乘</span><br><span class="line">x / y ;整除</span><br><span class="line">x :MOD: y ;取余</span><br><span class="line">x :ROL: y ;循环左移</span><br><span class="line">x :ROR: y ;循环右移</span><br><span class="line">x :SHL: y ;左移</span><br><span class="line">x :SHR: y ;右移</span><br><span class="line">x :AND: y ;按位与</span><br><span class="line">x :OR: y ;按位或</span><br><span class="line">:NOT: y ;按位取反</span><br><span class="line">x :EOR: y ;按位异或</span><br><span class="line">;逻辑表达式</span><br><span class="line">x = y </span><br><span class="line">x &gt; y</span><br><span class="line">x &lt; y</span><br><span class="line">x &gt;= y</span><br><span class="line">x &lt;= y</span><br><span class="line">x /= y ;不等于</span><br><span class="line">x &lt;&gt; y ;不等于</span><br><span class="line">x :LAND: y ;逻辑与</span><br><span class="line">x :LOR: y ;逻辑或</span><br><span class="line">x :LEOR: y ;逻辑异或</span><br><span class="line">:LNOT: y ;逻辑取反</span><br><span class="line">:LEN: x ;取长度（字符长度）</span><br><span class="line">:CHR: x ;将ASCII码转成字符</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>汇编语言</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>hdrtest</title>
    <url>/2024/06/14/hdrtest/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/DSC_1979-1.jpg"
                      alt="DSC_1979-1"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/DSC_1979.avif"
                     
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/DSC_1979.avif"
                      width="600" align="right"
                >



<p>
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/DSC_1979.avif"
                      width="200" aligh="right" alt class="wp-image-569"
                >
     一一一    
</p>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/DSC_1979-1.avif"
                     
                ></p>
]]></content>
  </entry>
  <entry>
    <title>Linux下文件及文件权限的管理</title>
    <url>/2024/07/04/Linux%E4%B8%8B%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>STM32产生延时的方法</title>
    <url>/2024/07/03/Stm32%E8%BD%AF%E4%BB%B6%E5%BB%B6%E6%97%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>RTOS</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim编辑器教程</title>
    <url>/2024/06/21/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Ubuntu终端ZSH配置</title>
    <url>/2024/06/21/Ubuntu%E7%BB%88%E7%AB%AFZSH%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="ZSH安装"><a href="#ZSH安装" class="headerlink" title="ZSH安装"></a>ZSH安装</h4><p>安装</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure></div>

<p>作为默认终端</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div>

<h4 id="oh-my-zsh安装"><a href="#oh-my-zsh安装" class="headerlink" title="oh-my-zsh安装"></a>oh-my-zsh安装</h4><p>oh-my-zsh是zsh的一个框架，内置了许多主题和插件。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>常用插件安装</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自动补齐</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line"><span class="comment">#语法高亮</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动跳转</span></span><br><span class="line">sudo apt-get install autojump</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 plugins 行添加插件名,如:</span></span><br><span class="line">plusgins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一行添加</span></span><br><span class="line">. /usr/share/autojump/autojump.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="ZSH常见问题"><a href="#ZSH常见问题" class="headerlink" title="ZSH常见问题"></a>ZSH常见问题</h4><ul>
<li><p><strong>不显示当前工作目录</strong></p>
<p>直接修改主题的设置</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br></pre></td></tr></table></figure></div>

<p>找到<code>%&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125;</code>，并将其中的<code>%c</code>改成<code>%d</code>。</p>
</li>
<li><p><strong>无法连接github</strong></p>
</li>
</ul>
<p>出现报错信息如下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure></div>

<p>这里不做过多的研究，一般认为是代理的问题。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy #设置代理</span><br><span class="line">git config --global --unset https.proxy #取消设置代理</span><br></pre></td></tr></table></figure></div>

<h4 id="略略略"><a href="#略略略" class="headerlink" title="略略略"></a>略略略</h4><ul>
<li><em><strong>框架可以使用zim或者其他的，提高运行性能。</strong></em></li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>ZSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之Shell基础</title>
    <url>/2024/06/21/Linux%E4%B9%8BShell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、Shell是什么"><a href="#一、Shell是什么" class="headerlink" title="一、Shell是什么"></a>一、Shell是什么</h3><p>​		我们现在的使用的操作系统都是带有图形界面的，早期的操作系统是使用命令行的。操作系统本身只是一些内核代码，图形化界面让我们可以简单的使用操作系统，命令行也是让我们能够对操作系统进行输入和输出。但是真正能够控制操作系统硬件的只有内核，不管是图形化界面还是命令行，他们都是帮助用户使用操作系统内核的工具，是用户和内核的桥梁。</p>
<p>​		对用户来说，他们不能也没有必要<strong>直接接触</strong>内核，这时候就需要有一个程序来帮助用户能够<strong>操作内核</strong>，这个程序就是Shell。Shell和其他的应用程序一样，不同的是，要使用Linux系统必须使用Shell。</p>
<p><del><em>现在的Linux发行版都有自带的图形化界面，使用图形化界面也可以</em></del></p>
<h4 id="二、Shell的工作原理"><a href="#二、Shell的工作原理" class="headerlink" title="二、Shell的工作原理"></a>二、Shell的工作原理</h4><p>​		Shell本身使用内核提供的<strong>接口</strong>进行工作，调用这些接口来实现对硬件的控制。</p>
<p>​		Shell自带的命令叫做<strong>内置命令</strong>，也可以使用其他应用程序叫做<strong>外部命令</strong>。</p>
<p>​		Shell通过<strong>调用其他的程序</strong>，并且将不同的程序通过数据的传递联系起来，<em>也就是将一个程序的输出作为另一个程序的输入</em>，就具备了非常强大的功能。</p>
<p>​		在Shell中键入一个命令，Shell会识别这是否是一个<strong>内部命令</strong>，如果不是则作为<strong>外部命令</strong>来执行，但是能够执行的外部命令必须存在于<strong>环境变量的路径</strong>中。</p>
<h4 id="三、Shell的使用"><a href="#三、Shell的使用" class="headerlink" title="三、Shell的使用"></a>三、Shell的使用</h4><p>​		在没有图形化界面的系统中，只能使用Shell来控制系统。</p>
<p>​		</p>
<h5 id="（1-控制台"><a href="#（1-控制台" class="headerlink" title="（1 控制台"></a>（1 控制台</h5><p>​		在Linux中也可以从图形界面直接进入<strong>Linux控制台（Console）</strong>，使用快捷键键 <code>Ctrl + Alt + Fn(n=2,3,4,5,6)</code> 。</p>
<p>​		在控制台中，用户登录后就进入了Shell。</p>
<h5 id="（2-终端"><a href="#（2-终端" class="headerlink" title="（2 终端"></a>（2 终端</h5><p>​		在Windows系统或者Linux桌面环境中，可以利用<strong>终端（Terminal）</strong>来使用Shell，其实终端本质上是一个终端模拟器，帮助用户在桌面环境下也可以使用Shell。</p>
<h4 id="四、Bash介绍"><a href="#四、Bash介绍" class="headerlink" title="四、Bash介绍"></a>四、Bash介绍</h4><p>​		Bash是大多数Linux系统的默认Shell，具有许多现代化的强大功能。</p>
<h4 id="五、PATH环境变量"><a href="#五、PATH环境变量" class="headerlink" title="五、PATH环境变量"></a>五、PATH环境变量</h4><p>Shell执行命令时，也可以调用其他程序。一般来说可以使用<em>绝对路径、相对路径或者环境变量</em>启动应用程序。这里的环境变量就是</p>
]]></content>
  </entry>
  <entry>
    <title>标准库开发PWM详解</title>
    <url>/2024/06/21/%E6%A0%87%E5%87%86%E5%BA%93%E5%BC%80%E5%8F%91PWM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>电子电路设计入门</title>
    <url>/2024/07/11/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="基本电路知识"><a href="#基本电路知识" class="headerlink" title="基本电路知识"></a>基本电路知识</h3><h4 id="电平"><a href="#电平" class="headerlink" title="电平"></a>电平</h4><p>高电平是1，低电平是0，在不同的供电系统中高电平大小不同，高低电平也并不是一个固定值而是一个范围。</p>
<h4 id="PWM脉冲宽度调制"><a href="#PWM脉冲宽度调制" class="headerlink" title="PWM脉冲宽度调制"></a>PWM脉冲宽度调制</h4><p>软件方法调节输出电压，占空比决定电压，有一个等效电压。</p>
<p><em>常用芯片：NE555，TL494，SG3525</em></p>
<h4 id="直流电和交流电"><a href="#直流电和交流电" class="headerlink" title="直流电和交流电"></a>直流电和交流电</h4><p>直流电就是方向不变的电流。直流电的电压存在波动，叫做纹波，测量电源的纹波需要使用示波器选择交流档。</p>
<p>交流电就是方向变化的电流，一般来说是正弦波交流电。具有一定的周期和频率，有效值是U&#x2F;1.414。</p>
<p>电压为正值意味着火线大于零线，负值意味着零线大于火线。</p>
<h4 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h4><ul>
<li>逻辑电路（控制电路） 几十mA</li>
<li>驱动电路 几百mA</li>
<li>功率电路 几A，高电压</li>
</ul>
<p>驱动电路和功率电路需要放在一起，并且和控制电路分开隔离。</p>
<h3 id="常用元器件"><a href="#常用元器件" class="headerlink" title="常用元器件"></a>常用元器件</h3><h4 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h4><p>电阻大小，功率，耐压。如果承受电压超过最大耐压，会被击穿，超过承受的最大功率可能烧毁。一般体积越大，功率和耐压越高。</p>
<p><em>常用电阻：直插电阻（色环电阻），贴片电阻，电位器，热敏电阻，水泥电阻</em></p>
<ul>
<li><p>直插电阻根据色环判断电阻大小。</p>
</li>
<li><p>贴片电阻一般是英制，用数字表示阻值大小，例如0201,0402。单位一般是欧姆。</p>
</li>
<li><p>电位器就是滑动变阻器，单联电位器和双联电位器。</p>
</li>
<li><p>热敏电阻也叫NTC用来测温。温度升高，电阻减小。</p>
</li>
<li><p>水泥电阻，在大功率场合用，充当负载。</p>
</li>
</ul>
<h4 id="电容器"><a href="#电容器" class="headerlink" title="电容器"></a>电容器</h4><p>储能作用，给电容器充电然后电容器就能释放充的电量。</p>
<p>隔直通交，隔绝直流但是可以通过交流电。</p>
<p>滤波作用，将直流电整形滤波。</p>
<p>电容的主要参数有容量和耐压。</p>
<p>单位一般是pF。</p>
<p><em>常用电容：贴片电容MLCC，瓷片电容，电解电容</em></p>
<p>* </p>
]]></content>
  </entry>
  <entry>
    <title>Git_SSH验证问题</title>
    <url>/2024/09/03/Git-SSH%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>重装系统后，尝试重新配置所有的环境，在使用Hexo博客进行部署时遇到了github无法连接的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240903235724103.png"
                      alt="image-20240903235724103"
                ></p>
<h4 id="一、寻找解决方案"><a href="#一、寻找解决方案" class="headerlink" title="一、寻找解决方案"></a>一、寻找解决方案</h4><ul>
<li>在上述的报错后直接yes，理论上会在个人的<code>.ssh</code>文件夹中创建一个<code>known_hosts</code>文件，此时加上私钥和公钥一共会有三个文件。</li>
</ul>
<p>如果能够正常创建<code>known_hosts</code>文件，理论上此时问题就会被解决。</p>
<p><strong>但是在这里我并没有解决问题，遂继续尝试其他方法</strong></p>
<ul>
<li>删除ssh文件，运行<code>ssh-keygen -t rsa -C &lt;邮箱&gt;</code>重新生成ssh秘钥，然后在github中上传新的公钥。理论上这里可以通过ssh验证连接，问题会被解决。</li>
</ul>
<p><strong>但是在这里我并没有解决问题，最终找到了问题所在</strong></p>
<ul>
<li>在前面不管怎么样都无法生成<code>known_hosts</code>文件，<strong>该文件内容未知</strong>，但是一定存在某种重要的作用，在github官方的帮助中可以找到解决方法。</li>
</ul>
<p><a class="link"   href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints" >GitHub 的 SSH 密钥指纹 - GitHub 文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>这里并不深究SSH秘钥指纹的知识。</em></p>
<p>直接在<code>.ssh</code>文件夹下创建新文件<code>known_hosts</code>并将官方给的秘钥条目添加进去，最终解决了问题。</p>
<p>在成功后尝试验证ssh连接，<code>ssh -T git@github.com</code>，应当出现以下的信息，即完全解决了问题。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></div>

<h4 id="二、后话"><a href="#二、后话" class="headerlink" title="二、后话"></a>二、后话</h4><p>重装系统后ssh秘钥失效，应该及时更换秘钥。</p>
<p>对git进行设置只是设置了本地用户的用户名和邮箱，如果要连接到远程仓库还需要https验证或者ssh验证。</p>
]]></content>
  </entry>
  <entry>
    <title>Git出现dubious_ownership错误</title>
    <url>/2024/09/03/Git%E5%87%BA%E7%8E%B0dubious-ownership%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我将电脑系统单独分了一个c盘，其他的软件资源都放在别的盘内，重装系统后只需要重新配置软件和注册表就可以和之前一样使用。</p>
<p>本次重装系统后，重新使用<strong>Hexo博客</strong>，发现不能够上传博客页面，报错看上去是说当前用户不是仓库拥有者。此时我以为是Git没有配置用户，所以不能推送到远程仓库，于是正常的<code>git config</code>后，问题依然没有解决，而在使用别的仓库时也出现的同样的报错，进行任何的<strong>git</strong>命令操作都会出现<code>dubious ownership</code>错误，接下来尝试解决该错误。</p>
<h4 id="一、为什么会出现这个错误"><a href="#一、为什么会出现这个错误" class="headerlink" title="一、为什么会出现这个错误"></a>一、为什么会出现这个错误</h4><p>出于安全考虑，Git会对仓库目录进行所有权的检查。如果你的仓库目录所有权和当前用户不匹配，Git就会给你抛出一个<code>fatal: detected dubious ownership in repository</code>的错误。</p>
<h4 id="二、两个解决方案"><a href="#二、两个解决方案" class="headerlink" title="二、两个解决方案"></a>二、两个解决方案</h4><h5 id="方案一：对Windows进行更改目录所有权"><a href="#方案一：对Windows进行更改目录所有权" class="headerlink" title="方案一：对Windows进行更改目录所有权"></a>方案一：对Windows进行更改目录所有权</h5><p>这里没有使用该方案，也没有进行尝试。</p>
<h5 id="方案二：将当前目录添加到安全目录例外"><a href="#方案二：将当前目录添加到安全目录例外" class="headerlink" title="方案二：将当前目录添加到安全目录例外"></a>方案二：将当前目录添加到安全目录例外</h5><p><code>git config --global --add safe.directory E:/project/UC-BMS</code></p>
<p>后面的目录换成对应的位置。</p>
<h4 id="三、解决问题后"><a href="#三、解决问题后" class="headerlink" title="三、解决问题后"></a>三、解决问题后</h4><p>使用方案二后，gitee网站可以进行仓库的连接。</p>
<p>但是在我的环境下还出现了不能够验证github的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://harderheng-blog.oss-cn-chengdu.aliyuncs.com/blogimage/image-20240903235724103.png"
                      alt="image-20240903235724103"
                ></p>
<p>在另一篇文章中将尝试解决这个问题。</p>
]]></content>
  </entry>
  <entry>
    <title>C++中哈希表的几种使用方式</title>
    <url>/2024/09/20/C-%E4%B8%AD%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一、哈希表详解"><a href="#一、哈希表详解" class="headerlink" title="一、哈希表详解"></a>一、哈希表详解</h3><p>哈希表由一个<em><strong>索引</strong></em>和一个<em><strong>值</strong></em>组成，一般哈希表用来<strong>快速判断一个元素是否出现在集合里</strong>。</p>
<p>将一个值映射到哈希表中的函数叫<strong>哈希函数</strong>，每个值都会被哈希函数映射成一个索引，直接查找这个索引就可以实现快速判断。</p>
<p>有时候哈希函数可能会导致两个不同的值被映射成了同一个索引，这叫做<strong>哈希碰撞</strong>。</p>
<p><em><strong>如何解决哈希碰撞？</strong></em></p>
<ul>
<li><strong>拉链法</strong> 在同一个哈希表的位置，</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC协议学习</title>
    <url>/2024/09/08/IIC%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>STM32</tag>
        <tag>I2C</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA入门</title>
    <url>/2024/09/04/FPGA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="一、电路设计"><a href="#一、电路设计" class="headerlink" title="一、电路设计"></a>一、电路设计</h3><h4 id="一、逻辑门"><a href="#一、逻辑门" class="headerlink" title="一、逻辑门"></a>一、逻辑门</h4><ul>
<li>与门</li>
<li>或门</li>
<li>非门</li>
<li>异或门</li>
<li>同或门</li>
</ul>
<h4 id="二、正逻辑和负逻辑"><a href="#二、正逻辑和负逻辑" class="headerlink" title="二、正逻辑和负逻辑"></a>二、正逻辑和负逻辑</h4><ul>
<li><strong>正逻辑</strong>中高电压是<em><strong>1</strong></em>，低电压是<em><strong>0</strong></em></li>
<li><strong>负逻辑</strong>中高电压是<em><strong>0</strong></em>，高电压是<em><strong>1</strong></em></li>
</ul>
<h4 id="三、逻辑函数的标准形式"><a href="#三、逻辑函数的标准形式" class="headerlink" title="三、逻辑函数的标准形式"></a>三、逻辑函数的标准形式</h4><h5 id="（1、最小项"><a href="#（1、最小项" class="headerlink" title="（1、最小项"></a>（1、最小项</h5><p>如果一个具有n个变量的函数的积包含全部的n个变量，每个变量都以原变量和反变量的形式出现一次，则称为最小项。</p>
]]></content>
  </entry>
  <entry>
    <title>Vivado入门</title>
    <url>/2024/09/04/Vivado%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
